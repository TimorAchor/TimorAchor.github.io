<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>About</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/RabbitMQ/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/RabbitMQ/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-29 21:18:20" itemprop="dateModified" datetime="2021-01-29T21:18:20+08:00">2021-01-29</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="1-学习目标"><a href="#1-学习目标" class="headerlink" title="1.学习目标"></a>1.学习目标</h1><p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20210129211635728.png" alt="image-20210129211635728"></p>
<h1 id="2-MQ简介"><a href="#2-MQ简介" class="headerlink" title="2.MQ简介"></a>2.MQ简介</h1><h3 id="1-1MQ概述"><a href="#1-1MQ概述" class="headerlink" title="1.1MQ概述"></a>1.1MQ概述</h3><p>MQ全称Message Queue (消息队列)，是在消息的传输过程中保存消息的容器。多用于分布式系统之间进行通信。</p>
<img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20200722195149829.png" alt="image-20200722195149829" style="zoom: 67%;" />

<ul>
<li>MQ,消息队列，存储消息的中间件</li>
<li>分布式系统通信两种方式：直接远程调用和借助第三方 完成间接通信</li>
<li>发送方称为生产者，接收方称为消费者</li>
</ul>
<h3 id="1-2MQ的优势和劣势"><a href="#1-2MQ的优势和劣势" class="headerlink" title="1.2MQ的优势和劣势"></a>1.2MQ的优势和劣势</h3><p>优势:</p>
<ul>
<li>应用解耦</li>
<li>异步提速</li>
<li>削峰填谷</li>
</ul>
<p>劣势：</p>
<ul>
<li>系统可用性降低</li>
<li>系统复杂度提高</li>
<li>一致性问题</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/ElasticSearch/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/ElasticSearch/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-10-19 09:35:08" itemprop="dateModified" datetime="2020-10-19T09:35:08+08:00">2020-10-19</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="狂神聊ElasticSearch"><a href="#狂神聊ElasticSearch" class="headerlink" title="狂神聊ElasticSearch"></a>狂神聊ElasticSearch</h1><p>版本  ElasticSearch7.6.1</p>
<blockquote>
<p>我们要讲解什么</p>
</blockquote>
<p>SQL：like %狂神说%，如果是大数据，就十分慢！索引！</p>
<p>ElasticSearch : 搜素！(百度、github、淘宝电商)</p>
<ol>
<li>聊一个人</li>
<li>货比三家</li>
<li>安装</li>
<li>生态圈</li>
<li>分词器 ik</li>
<li>RestFul操作  ES</li>
<li>CRUD</li>
<li>SpringBoot集成ElasticSearch （从原理分析！）</li>
<li>爬虫爬取数据！</li>
<li>实战，模拟全文检索！</li>
</ol>
<p>以后你只要，需要用到搜索，就可以使用ES！（大数据情况下使用！ ） </p>
<p><strong>Lucene和ElasticSearch关系</strong></p>
<p>ElasticSearch是基于Lucene 做了一些封装和增强（我们上手是十分简单的！）</p>
<h1 id="ElasticSearch概述"><a href="#ElasticSearch概述" class="headerlink" title="ElasticSearch概述"></a>ElasticSearch概述</h1><p>ElasticSearch，简称es, es是一个开源的高扩展的分布式全文检索引擎，它可以近乎实时的存储、检索数据；本身扩展性很好，可以扩展到上百台服务器，处理PB级别（大数据时代）的数据。es也使用Java开发并使用Luence作为其核心来实现所有索引和搜索的功能，但是他的目的是通过简单的RESTful API来隐藏Luence的复杂性，从而让全文搜索变得简单。</p>
<h1 id="ElasticSearch安装"><a href="#ElasticSearch安装" class="headerlink" title="ElasticSearch安装"></a>ElasticSearch安装</h1><p>声明：JDK1.8，最低要求</p>
<blockquote>
<p>下载</p>
</blockquote>
<p>官网：<a target="_blank" rel="noopener" href="https://www.elastic.co/cn/downloads/elasticsearch">https://www.elastic.co/cn/downloads/elasticsearch</a></p>
<blockquote>
<p>windows下安装</p>
</blockquote>
<p>1.解压</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007141948537.png" alt="image-20201007141948537"></p>
<p> <img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007142513016.png" alt="image-20201007142513016"></p>
<blockquote>
<p>安装可视化界面es head的插件</p>
</blockquote>
<ol>
<li><p>下载地址：<a target="_blank" rel="noopener" href="https://github.com/mobz/elasticsearch-head">https://github.com/mobz/elasticsearch-head</a></p>
</li>
<li><p>启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br><span class="line">npm run start</span><br></pre></td></tr></table></figure>
</li>
<li><p>连接测试发现，存在跨域问题</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">http.cors.enabled:</span> <span class="literal">true</span> </span><br><span class="line"><span class="attr">http.cors.allow-origin:</span> <span class="string">&quot;*&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>重启es服务，再次连接</p>
</li>
<li><p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007143357450.png" alt="image-20201007143357450"></p>
</li>
</ol>
<p>初学者，把es当作一个数据库！（可以建立索引（库），文档（库中的数据！））</p>
<blockquote>
<p>这个head我们就把它当做数据展示工具！后的我们的查询用Kibana</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007202331152.png" alt="image-20201007202331152"></p>
<h1 id="ES核心"><a href="#ES核心" class="headerlink" title="ES核心"></a>ES核心</h1><ol>
<li>索引</li>
<li>字段类型(mapping)</li>
<li>文档(documents)</li>
</ol>
<blockquote>
<p>概述</p>
</blockquote>
<p>在前面的学习中，我们已经掌握了es是什么，同时也把es的服务安装启动，那么es是如何去存储数据，数据结构是什么，又是如何实现搜素的呢？我们先来聊聊ElasticSearch的相关概念吧！</p>
<p>==<code>集群 节点 索引 类型 文档 分片 映射 是什么</code>==</p>
<blockquote>
<p>elasticsearch是面向文档，关系型数据库和elasticsearch的客观对比</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007203042925.png" alt="image-20201007203042925"></p>
<p>elasticsearch(集群)中可以包含多个多个索引（数据库），每个索引中可以包含多个类型（表），每个类型下又包含多个文档（行），每个文档中又包含多个字段（列）。</p>
<p><strong>物理设计：</strong></p>
<p>elasticsearch 在后台把每个索引划分成多个分片，每分分片可以在集群中的不同服务器间迁移</p>
<p><strong>逻辑设计：</strong></p>
<p>一个索引类型中，包含多个文档，比如说文档1，文档2。当我们索引一篇文章时，可以通过这样的一个顺序找到它：索引    》 类型 》文档ID，通过这个组合我们就能索引到某个具体的文档。注意：ID不必是整数，实际上它是个字符串。</p>
<blockquote>
<p>文档</p>
</blockquote>
<p><code>就是我们的一条条数据</code></p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">user</span></span><br><span class="line"><span class="number">1</span>	<span class="string">zhangsna</span>	<span class="number">18</span></span><br><span class="line"><span class="number">2</span>	<span class="string">kuangshen</span>	<span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>之前说elasticsearch是面向文档的，那么就意味着索引和搜索数据的最小单位是文档。elasticsearch中，文档有几个重要属性：</p>
<ul>
<li>自我包含，一篇文档同时包含字段和对应的值，也就是同时包含key：value</li>
<li>可以是层次型的，一个文档中包含子文档，复杂的逻辑实体就是这么来的</li>
<li>灵活的结构，文档不依赖预先定义的模式，我们知道关系型数据库中，要提前定义字段才能使用，在elasticsearch中，对于字段是非常灵活的，有时候，我们可以忽略该字段，或者动态的添加一个新的字段。</li>
</ul>
<p>尽管我们可以随意的新增或者忽略某个字段，但是，每个字段的类型非常重要，比如一个年龄字段类型，可以是字符串也可以是整型。因为elasticsearch会保存字段和类型之间的映射及其他的设置。这种映射具体到每个映射的每种类型，这也是为什么在elasticsearch中，类型有时候也称为映射类型。</p>
<blockquote>
<p>类型</p>
</blockquote>
<p>类型是文档的逻辑容器，就像关系型数据库一样，表格是行的容器。类型中对于字段的定义称为映射，比如name映射为字符串类型。我们说文档是无模式的，它们不需要拥有映射中所定义的所有字段，比如新增一个字段，那么elasticsearch是怎么做的呢？elasticsearch会自动的将新字段加入映射，但是这个字段的不确定它是什么类型，elasticsearch就开始猜，如果这个值是18，那么elasticsearch也可能猜不对，所以最安全的方式就是提前定义好所需要的映射，这点跟关系型数据库殊途同归了，先定义好字段，然后再使用。</p>
<blockquote>
<p>索引</p>
</blockquote>
<p><code>就是数据库</code></p>
<p>索引是映射类型的容器，elasticsearch中的索引是一个非常大的文档集合。索引存储了映射类型的字段和其他设置。然后它们被存储到了各个分片上了。我们来研究下分片是如何工作的。</p>
<p><strong>物理设计：节点和分片是如何工作的</strong></p>
<p>一个集群至少有一个节点，而一个节点就是一个elasticsearch进程，节点可以有多个索引默认的，如果你创建索引，那么索引就会有5个分片（primary shard,又称主分片）构成的，每一个分片会有一个副本（replica sahrd，又称复制分片）</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007213807806.png" alt="image-20201007213807806"></p>
<blockquote>
<p>倒排索引</p>
</blockquote>
<p>elasticsearch使用的是一种称为倒排索引的结构，采用Lunence倒排索引作为底层。这种结构适用于快速的全文搜索，一个索引由文档中所有不重复的列表构成，对于每一个词，都有一个包含它的文档列表。</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201007215540884.png" alt="image-20201007215540884"></p>
<h1 id="IK分词器"><a href="#IK分词器" class="headerlink" title="IK分词器"></a>IK分词器</h1><blockquote>
<p>什么是IK分词器</p>
</blockquote>
<p>分词：即把一段中文或者别的词划分成一个个的关键字，我们再搜索时候会把自己的信息进行分词，会把数据库中或者索引库中的数据进行分词，然后进行一个匹配操作，默认的中文分词是将每个字看成一个词，这显然是不符合要求的，所以我们需要安装中文分词器ik来解决这个问题。</p>
<p>IK分词器提供了两个分词算法：ik_smart 和 ik_max_word, 其中 ik_smart 为最少切分， ik_max_word 为最细粒度划分！一会我们测试！</p>
<blockquote>
<p>安装</p>
</blockquote>
<ol>
<li><p><a target="_blank" rel="noopener" href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
</li>
<li><p>下载完毕之后，放入到我们的elasticsearch 的插件文件夹下</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201008184536439.png" alt="image-20201008184536439"></p>
</li>
<li><p>重启观察es，可以看到ik分词器被加载了</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201008184553518.png" alt="image-20201008184553518"></p>
</li>
<li><p>elasticsearch-plugin list通过这个命令可以查看加载进来的插件</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201008184433639.png" alt="image-20201008184433639"></p>
</li>
<li><p>使用kibana测试</p>
<blockquote>
<p>查看不同的分词器效果</p>
</blockquote>
</li>
</ol>
<p>​       ik_smart 为最少切分， ik_max_word 为最细粒度划分</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201008202651044.png" alt="image-20201008202651044"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201008202719056.png" alt="image-20201008202719056"></p>
<blockquote>
<p>ik分词器增加自己的配置</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201008204455890.png" alt="image-20201008204455890"></p>
<p>重启es</p>
<h1 id="Rest风格说明"><a href="#Rest风格说明" class="headerlink" title="Rest风格说明"></a>Rest风格说明</h1><p>一种软件架构风格，而不是标准，只是提供了一组设计原则和约束条件。它主要用于客户端和服务器交互类的软件。基于这个风格的设计的软件可以更简洁，更有层次，更易于实现缓存等机制。</p>
<p>基本Rest命令说明：</p>
<table>
<thead>
<tr>
<th>method</th>
<th align="left">url地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>PUT</td>
<td align="left">localhost:9200/索引名称/类型名称/文档id</td>
<td>创建文档（指定文档id）</td>
</tr>
<tr>
<td>POST</td>
<td align="left">localhost:9200/索引名称/类型名称</td>
<td>创建文档（随机文档id）</td>
</tr>
<tr>
<td>POST</td>
<td align="left">localhost:9200/索引名称/类型名称/文档id/_update</td>
<td>修改文档</td>
</tr>
<tr>
<td>DELETE</td>
<td align="left">localhost:9200/索引名称/类型名称/文档id/</td>
<td>删除文档</td>
</tr>
<tr>
<td>GET</td>
<td align="left">localhost:9200/索引名称/类型名称/文档id/</td>
<td>查询文档通过文档id</td>
</tr>
<tr>
<td>POST</td>
<td align="left">localhost:9200/索引名称/类型名称/_search</td>
<td>查询所有数据</td>
</tr>
</tbody></table>
<h1 id="关于索引的基本操作"><a href="#关于索引的基本操作" class="headerlink" title="关于索引的基本操作"></a>关于索引的基本操作</h1><p>1.创建一个索引</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;索引名&#x2F;~类型名~&#x2F;文档id</span><br><span class="line">&#123;请求体&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009203342433.png" alt="image-20201009203342433"></p>
<p>完成了自动增加了索引！数据也成功的添加了，这就是初期可以把它当成数据库学的原因。</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009205335063.png" alt="image-20201009205335063"></p>
<p>3.那么name这个字段用不用指定类型呢。毕竟我们关系型数据库是需要指定类型的</p>
<ul>
<li><p>字符串类型</p>
<p>text、keyword</p>
</li>
<li><p>数值类型</p>
<p>long、integer、short、byte、double、float、half、scaled、float</p>
</li>
<li><p>日期类型</p>
<p>date</p>
</li>
<li><p>布尔值类型</p>
<p>boolean</p>
</li>
<li><p>二进制类型</p>
<p>binary</p>
</li>
<li><p>等等……</p>
</li>
</ul>
<p>4.指定字段的类型</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009214650908.png" alt="image-20201009214650908"></p>
<p> <img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009215103078.png" alt="image-20201009215103078"></p>
<p>5.获得这个规则！可以通过GET请求获取具体的信息</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009215242115.png" alt="image-20201009215242115"></p>
<p>5.查看默认的信息</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009220441967.png" alt="image-20201009220441967"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009220540134.png" alt="image-20201009220540134"></p>
<p>如果自己的文档字段没有指定，那么es就会给我们默认配置字段类型！</p>
<p>扩展：通过命令 elasticsearch索引情况！通过get  _cat/ 可以获得es的当前的很多信息</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009221309551.png" alt="image-20201009221309551"></p>
<blockquote>
<p>修改 提交还是使用PUT即可！ 然后覆盖！最新办法！两种方法！</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009222510194.png" alt="image-20201009222510194"></p>
<blockquote>
<p>删除索引</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201009222618333.png" alt="image-20201009222618333"></p>
<p>通过DELETE命令实现删除、根据你请求的来判断是删除索引还是删除文档记录！</p>
<p>推荐使用RESTFUL风格使用ES</p>
<h1 id="关于文档的基本操作"><a href="#关于文档的基本操作" class="headerlink" title="关于文档的基本操作"></a>关于文档的基本操作</h1><blockquote>
<p>基本操作</p>
</blockquote>
<p>1.添加数据</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;kuangshen&#x2F;user&#x2F;1</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;狂神说&quot;,</span><br><span class="line">  &quot;age&quot;:23,</span><br><span class="line">  &quot;desc&quot;:&quot;一顿操作猛如虎&quot;,</span><br><span class="line">  &quot;tags&quot;:[&quot;宅&quot;,&quot;暖男&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014100559709.png" alt="image-20201014100559709"></p>
<p>2.获取数据 GET</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014101527996.png" alt="image-20201014101527996"></p>
<p>3.更新数据 PUT</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014101915702.png" alt="image-20201014101915702"></p>
<p>4.POST   _update ,    推荐使用这种更新方式</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014102422741.png" alt="image-20201014102422741"></p>
<p>简单的搜索</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET kuangshen&#x2F;user&#x2F;1</span><br></pre></td></tr></table></figure>

<p>简单的条件查询，可以根据默认的映射规则，产生基本的查询！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET kuangshen&#x2F;user&#x2F;_search?q&#x3D;name:狂神说</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014110322312.png" alt="image-20201014110322312"></p>
<blockquote>
<p>复杂操作搜索  select (排序，分页，高亮，模糊查询，精准查询！)</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014134142373.png" alt="image-20201014134142373"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014135522892.png" alt="image-20201014135522892"></p>
<p>用_source 来选择展示的字段，实现结果的过滤</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014135742979.png" alt="image-20201014135742979"></p>
<p> 我们之后使用Java操作es，所有的方法和对象就是这里面的key！</p>
<blockquote>
<p>排序   sort</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014165506380.png" alt="image-20201014165506380"></p>
<blockquote>
<p>分页查询  from  size</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201014170836390.png" alt="image-20201014170836390"></p>
<p>/search/{current}/{pagesize}</p>
<blockquote>
<p>布尔值查询</p>
</blockquote>
<p>must（相当于and），所有条件都要符合</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015100050192.png" alt="image-20201015100050192"></p>
<p>should (相当于or)</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015100445578.png" alt="image-20201015100445578"></p>
<p> must_not (相当于not)</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015101419638.png" alt="image-20201015101419638"></p>
<p>过滤器（filter）</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015103214791.png" alt="image-20201015103214791"></p>
<ul>
<li>gt 大于</li>
<li>gte 大于等于</li>
<li>lt 小于</li>
<li>lte 小于等于</li>
</ul>
<blockquote>
<p>匹配多个条件</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015104654932.png" alt="image-20201015104654932"></p>
<blockquote>
<p>精确查询！</p>
</blockquote>
<p>term查询是直接通过倒排索引指定的词条进程精确查找的！</p>
<p><strong>关于分词</strong>：</p>
<ul>
<li><p>term，直接查询精确的</p>
</li>
<li><p>match，会使用分词器解析！（先分析文档，然后通过分析的文档进行查询！）</p>
</li>
</ul>
<p><strong>两个类型 text keyword</strong></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015112303560.png" alt="image-20201015112303560"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015112327732.png" alt="image-20201015112327732"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015113617282.png" alt="image-20201015113617282"></p>
<blockquote>
<p>多个值匹配的精确查询</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015114704023.png" alt="image-20201015114704023"></p>
<blockquote>
<p>高亮查询</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015115300558.png" alt="image-20201015115300558"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015115707804.png" alt="image-20201015115707804"></p>
<ul>
<li>匹配</li>
<li>按条件匹配</li>
<li>精确匹配</li>
<li>区间范围匹配</li>
<li>匹配字段过滤</li>
<li>多条件查询</li>
<li>高亮查询</li>
</ul>
<h1 id="集成SpringBoot"><a href="#集成SpringBoot" class="headerlink" title="集成SpringBoot"></a>集成SpringBoot</h1><ol>
<li><p>找到原生的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.elasticsearch.client&lt;&#x2F;groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;&#x2F;artifactId&gt;</span><br><span class="line">    &lt;version&gt;7.6.2&lt;&#x2F;version&gt;</span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201015142602828.png" alt="image-20201015142602828"></p>
</li>
<li><p>分析这个类中的方法即可</p>
</li>
</ol>
<blockquote>
<p>配置Config配置类</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticSearchClientConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">restHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestHighLevelClient client = <span class="keyword">new</span> RestHighLevelClient(</span><br><span class="line">                RestClient.builder(</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9200</span>, <span class="string">&quot;http&quot;</span>),</span><br><span class="line">                        <span class="keyword">new</span> HttpHost(<span class="string">&quot;localhost&quot;</span>, <span class="number">9201</span>, <span class="string">&quot;http&quot;</span>)));</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>具体的API测试</p>
</blockquote>
<ol>
<li>创建索引</li>
<li>判断索引是否存在</li>
<li>删除索引</li>
<li>创建文档</li>
<li>CRUD文档</li>
</ol>
<blockquote>
<p>索引的API操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimorEsApiApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;restHighLevelClient&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//测试索引的创建   Request</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testCreateIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//1.创建索引请求</span></span><br><span class="line">      CreateIndexRequest request = <span class="keyword">new</span> CreateIndexRequest(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">      <span class="comment">//2.客户端执行请求 IndicesClient,请求后获得响应</span></span><br><span class="line">      CreateIndexResponse createIndexResponse = client.indices().create(request, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(createIndexResponse);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//测试获取索引，判断其是否存在</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testExistIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      GetIndexRequest request = <span class="keyword">new</span> GetIndexRequest(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">      <span class="keyword">boolean</span> exists = client.indices().exists(request, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(exists);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//测试删除索引</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testDeleteIndex</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      DeleteIndexRequest request = <span class="keyword">new</span> DeleteIndexRequest(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">      AcknowledgedResponse delete = client.indices().delete(request, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(delete);</span><br><span class="line">      System.out.println(delete.isAcknowledged());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>文档 的API操作</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimorEsApiApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="meta">@Autowired</span></span><br><span class="line">   <span class="meta">@Qualifier(&quot;restHighLevelClient&quot;)</span></span><br><span class="line">   <span class="keyword">private</span> RestHighLevelClient client;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//测试添加文档</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAddDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      <span class="comment">//创建对象</span></span><br><span class="line">      User user = <span class="keyword">new</span> User(<span class="string">&quot;狂神说&quot;</span>,<span class="number">3</span>);</span><br><span class="line">      <span class="comment">//创建请求</span></span><br><span class="line">      IndexRequest request = <span class="keyword">new</span> IndexRequest(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">      <span class="comment">//规则 put /kuang_index/_doc/1</span></span><br><span class="line">      request.id(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      request.timeout(TimeValue.timeValueSeconds(<span class="number">1</span>));</span><br><span class="line">      request.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">      <span class="comment">//将我们的数据放入请求 json</span></span><br><span class="line">      IndexRequest source = request.source(JSON.toJSONString(user), XContentType.JSON);</span><br><span class="line">      <span class="comment">//客户端发送请求,获取响应结果</span></span><br><span class="line">      IndexResponse indexResponse = client.index(request, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(indexResponse.toString());</span><br><span class="line">      System.out.println(indexResponse.status());       <span class="comment">//对应我们命令返回的状态</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取文档，判断是否存在</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testIsExists</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;kuang_index&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      <span class="comment">//不获取返回的_source的上下文了</span></span><br><span class="line">      getRequest.fetchSourceContext(<span class="keyword">new</span> FetchSourceContext(<span class="keyword">false</span>));</span><br><span class="line">      getRequest.storedFields(<span class="string">&quot;_none_&quot;</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">boolean</span> exists = client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(exists);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获得文档信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testGetDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">&quot;kuang_index&quot;</span>,<span class="string">&quot;1&quot;</span>);</span><br><span class="line">      GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(getResponse.getSourceAsString());</span><br><span class="line">      System.out.println(getResponse);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 更新文档的信息</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testUpdateDocument</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      updateRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">      User user = <span class="keyword">new</span> User(<span class="string">&quot;狂神说Java&quot;</span>,<span class="number">18</span>);</span><br><span class="line">      updateRequest.doc(JSON.toJSONString(user),XContentType.JSON);</span><br><span class="line">      UpdateResponse updateResponse = client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(updateResponse.status());</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除文档记录</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testDeleteRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">&quot;kuang_index&quot;</span>, <span class="string">&quot;1&quot;</span>);</span><br><span class="line">      deleteRequest.timeout(<span class="string">&quot;1s&quot;</span>);</span><br><span class="line">      DeleteResponse deleteResponse = client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(deleteResponse.status());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//真实的项目一般采用批量插入数据</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testBulkRequest</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">      BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">      bulkRequest.timeout(<span class="string">&quot;10s&quot;</span>);</span><br><span class="line">      ArrayList&lt;User&gt; userList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">      userList.add(<span class="keyword">new</span> User(<span class="string">&quot;kuangshen1&quot;</span>,<span class="number">1</span>));</span><br><span class="line">      userList.add(<span class="keyword">new</span> User(<span class="string">&quot;kuangshen2&quot;</span>,<span class="number">2</span>));</span><br><span class="line">      userList.add(<span class="keyword">new</span> User(<span class="string">&quot;kuangshen3&quot;</span>,<span class="number">3</span>));</span><br><span class="line">      userList.add(<span class="keyword">new</span> User(<span class="string">&quot;kuangshen4&quot;</span>,<span class="number">4</span>));</span><br><span class="line">      userList.add(<span class="keyword">new</span> User(<span class="string">&quot;kuangshen5&quot;</span>,<span class="number">5</span>));</span><br><span class="line">      userList.add(<span class="keyword">new</span> User(<span class="string">&quot;kuangshen6&quot;</span>,<span class="number">6</span>));</span><br><span class="line"></span><br><span class="line">      <span class="comment">//批处理请求</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; userList.size(); i++) &#123;</span><br><span class="line">         bulkRequest.add(</span><br><span class="line">               <span class="keyword">new</span> IndexRequest(<span class="string">&quot;kuang_index&quot;</span>)</span><br><span class="line">               .id(<span class="string">&quot;&quot;</span>+(i+<span class="number">1</span>))</span><br><span class="line">               .source(JSON.toJSONString(userList.get(i)),XContentType.JSON));</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      BulkResponse bulkResponse = client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(bulkResponse.hasFailures());          <span class="comment">//是否失败</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//查询</span></span><br><span class="line">   <span class="comment">//SearchRequest 搜索请求</span></span><br><span class="line">   <span class="comment">//SearchSourceBuilder 条件构造</span></span><br><span class="line">   <span class="comment">//HighLightBuilder 构建高亮</span></span><br><span class="line">   <span class="comment">//TermQueryBuilder 精确查询</span></span><br><span class="line">   <span class="comment">//MatchAllQueryBuilder  等等  对应所有命令</span></span><br><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">testSearch</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">      SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest(<span class="string">&quot;kuang_index&quot;</span>);</span><br><span class="line">      <span class="comment">//构建搜索的条件</span></span><br><span class="line">      SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">      <span class="comment">//查询条件，我们可以使用QueryBuilders工具类实现快速匹配</span></span><br><span class="line">      TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;kuangshen1&quot;</span>);</span><br><span class="line">      searchSourceBuilder.query(termQueryBuilder);</span><br><span class="line">      searchSourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS)) ;</span><br><span class="line">      searchRequest.source(searchSourceBuilder);</span><br><span class="line">      SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">      System.out.println(JSON.toJSONString(searchResponse.getHits()));</span><br><span class="line">      System.out.println(<span class="string">&quot;===============================&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (SearchHit documentFields : searchResponse.getHits().getHits()) &#123;</span><br><span class="line">         System.out.println(documentFields.getSourceAsMap());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h1><h3 id="爬虫"><a href="#爬虫" class="headerlink" title="爬虫"></a>爬虫</h3><blockquote>
<p>数据问题</p>
</blockquote>
<p>爬取数据：（获取请求返回的页面信息，筛选出我们想要的数据就可以了）</p>
<p>jsoup！</p>
<p>导入依赖</p>
<h3 id="前后端分离"><a href="#前后端分离" class="headerlink" title="前后端分离"></a>前后端分离</h3><h3 id="搜索高亮"><a href="#搜索高亮" class="headerlink" title="搜索高亮"></a>搜索高亮</h3><blockquote>
<p>备注</p>
</blockquote>
<p>npm命令解释</p>
<ul>
<li><p><code>npm install moduleName</code>: 安装模块到项目目录下</p>
</li>
<li><p><code>npm install -g moduleName</code>: -g的意思是将模块安装到全局，具体安装到磁盘哪个位置，要看npm config prefix的位置</p>
</li>
<li><p><code>npm install -save moduleName</code>: -save的意思是将模块安装到项目目录下，并在package文件的dependencies节点写入依赖，-S为该命令的缩写。</p>
</li>
<li><p>``npm install -save-dev moduleName`:  -save-dev的意思是将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖，-D为该命令的缩写。</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/docker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/docker/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-17 21:19:57" itemprop="dateModified" datetime="2020-12-17T21:19:57+08:00">2020-12-17</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="狂神说Docker入门"><a href="#狂神说Docker入门" class="headerlink" title="狂神说Docker入门"></a>狂神说Docker入门</h1><blockquote>
<p>Docker学习大纲</p>
</blockquote>
<ul>
<li>Docker概述</li>
<li>Docker安装</li>
<li>Docker命令<ul>
<li>镜像命令</li>
<li>容器命令</li>
<li>操作命令</li>
<li>……</li>
</ul>
</li>
<li>Docker镜像</li>
<li>容器数据卷</li>
<li>DockerFile</li>
<li>IDEA整合Docker</li>
<li>Docker Compose</li>
<li>Docker Swarm</li>
<li>CI/CD jenkins </li>
</ul>
<h1 id="Docker概述"><a href="#Docker概述" class="headerlink" title="Docker概述"></a>Docker概述</h1><p><strong>Docker为什么出现？</strong></p>
<p>一款产品： 开发–上线 两套环境！应用环境，应用配置！</p>
<p>开发 — 运维。 问题：我在我的电脑上可以允许！版本更新，导致服务不可用！对于运维来说考验十分大？</p>
<p>环境配置是十分的麻烦，每一个及其都要部署环境(集群Redis、ES、Hadoop…) !费事费力。</p>
<p>发布一个项目( jar + (Redis MySQL JDK ES) ),项目能不能带上环境安装打包！</p>
<p>之前在服务器配置一个应用的环境 Redis MySQL JDK ES Hadoop 配置超麻烦了，不能够跨平台。</p>
<p>开发环境Windows，最后发布到Linux！</p>
<p>传统：开发jar，运维来做！</p>
<p>现在：开发打包部署上线，一套流程做完！</p>
<p>安卓流程：java — apk —发布（应用商店）一 张三使用apk一安装即可用！</p>
<p>docker流程： java-jar（环境） — 打包项目帯上环境（镜像） — ( Docker仓库：商店）—–</p>
<p>Docker给以上的问题，提出了解决方案！</p>
<p>Docker的思想就来自于集装箱！</p>
<p>JRE – 多个应用(端口冲突) – 原来都是交叉的！<br>隔离：Docker核心思想！打包装箱！每个箱子是互相隔离的。</p>
<p>Docker通过隔离机制，可以将服务器利用到极致！</p>
<p>本质：所有的技术都是因为出现了一些问题，我们需要去解决，才去学习！</p>
<h1 id="Docker历史"><a href="#Docker历史" class="headerlink" title="Docker历史"></a>Docker历史</h1><p>2010年，几个的年轻人，就在美国成立了一家公司 <code>dotcloud</code></p>
<p>做一些pass的云计算服务！LXC（Linux Container容器）有关的容器技术！</p>
<p>Linux Container容器是一种内核虚拟化技术，可以提供轻量级的虚拟化，以便隔离进程和资源。</p>
<p>他们将自己的技术（容器化技术）命名就是 Docker<br>Docker刚刚延生的时候，没有引起行业的注意！dotCloud，就活不下去！</p>
<blockquote>
<p>开源</p>
</blockquote>
<p>2013年，Docker开源！</p>
<p>越来越多的人发现docker的优点！火了。Docker每个月都会更新一个版本！</p>
<p>2014年4月9日，Docker1.0发布！</p>
<p>docker为什么这么火？十分的轻巧！</p>
<p>在容器技术出来之前，我们都是使用虚拟机技术！</p>
<p>虚拟机：在window中装一个VMware，通过这个软件我们可以虚拟出来一台或者多台电脑！笨重！</p>
<p>虚拟机也属于虚拟化技术，Docker容器技术，也是一种虚拟化技术！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VMware : linux centos 原生镜像（一个电脑！） 隔离、需要开启多个虚拟机！ 几个G 几分钟</span><br><span class="line">docker: 隔离，镜像（最核心的环境 4m + jdk + mysql）十分的小巧，运行镜像就可以了！小巧！ 几个M 秒级启动！</span><br><span class="line">12</span><br></pre></td></tr></table></figure>

<blockquote>
<p>聊聊Docker</p>
</blockquote>
<p>Docker基于Go语言开发的！开源项目！</p>
<p>docker官网：<a target="_blank" rel="noopener" href="https://www.docker.com/">https://www.docker.com/</a></p>
<p>文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/">https://docs.docker.com/</a> Docker的文档是超级详细的！</p>
<p>仓库：<a target="_blank" rel="noopener" href="https://hub.docker.com/">https://hub.docker.com/</a></p>
<h3 id="Docker能干嘛"><a href="#Docker能干嘛" class="headerlink" title="Docker能干嘛"></a>Docker能干嘛</h3><blockquote>
<p>之前的虚拟机技术<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE1Mzg1Mjk1NC5wbmc?x-oss-process=image/format,png" alt="image-20200515153852954"><br><strong>虚拟机技术缺点</strong>：</p>
</blockquote>
<p>1、 资源占用十分多</p>
<p>2、 冗余步骤多</p>
<p>3、 启动很慢！</p>
<blockquote>
<p>容器化技术</p>
</blockquote>
<p>容器化技术不是模拟一个完整的操作系统</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTA5NDMzNjg0Ni5wbmc?x-oss-process=image/format,png" alt="image-20200515094336846"></p>
<p>比较Docker和虚拟机技术的不同：</p>
<ul>
<li>传统虚拟机，虚拟出一条硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li>
<li>容器内的应用直接运行在宿主机的内容，容器是没有自己的内核的，也没有虚拟我们的硬件，所以就轻便了</li>
<li>每个容器间是互相隔离，每个容器内都有一个属于自己的文件系统，互不影响</li>
</ul>
<blockquote>
<p>DevOps（开发、运维）</p>
</blockquote>
<p><strong>应用更快速的交付和部署</strong></p>
<p>传统：一对帮助文档，安装程序。</p>
<p>Docker：打包镜像发布测试一键运行。</p>
<p><strong>更便捷的升级和扩缩容</strong></p>
<p>使用了 Docker之后，我们部署应用就和搭积木一样<br>项目打包为一个镜像，扩展服务器A！服务器B</p>
<p><strong>更简单的系统运维</strong><br>在容器化之后，我们的开发，测试环境都是高度一致的</p>
<p><strong>更高效的计算资源利用</strong></p>
<p>Docker是内核级别的虚拟化，可以在一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p>
<h1 id="Docker安装"><a href="#Docker安装" class="headerlink" title="Docker安装"></a>Docker安装</h1><h4 id="Docker的基本组成"><a href="#Docker的基本组成" class="headerlink" title="Docker的基本组成"></a>Docker的基本组成</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNDE5NTgwNTQwMC5wbmc?x-oss-process=image/format,png" alt="image-20200514195805400"></p>
<p><strong>镜像（image)：</strong></p>
<p>docker镜像就好比是一个目标，可以通过这个目标来创建容器服务，tomcat镜像==&gt;run==&gt;容器（提供服务器），通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）。</p>
<p><strong>容器(container)：</strong></p>
<p>Docker利用容器技术，独立运行一个或者一组应用，通过镜像来创建的.<br>启动，停止，删除，基本命令<br>目前就可以把这个容器理解为就是一个简易的 Linux系统。</p>
<p><strong>仓库(repository)：</strong></p>
<p>仓库就是存放镜像的地方！<br>仓库分为公有仓库和私有仓库。(很类似git)<br>Docker Hub是国外的。<br>阿里云…都有容器服务器(配置镜像加速!)</p>
<h4 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h4><blockquote>
<p>环境准备</p>
</blockquote>
<p>1.Linux要求内核3.0以上</p>
<p>2.CentOS 7</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@iz2zeak7sgj6i7hrb2g862z ~]# uname -r</span><br><span class="line">3.10.0-514.26.2.el7.x86_64	# 要求3.0以上</span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z ~]# cat /etc/os-release </span><br><span class="line">NAME=&quot;CentOS Linux&quot;</span><br><span class="line">VERSION=&quot;7 (Core)&quot;</span><br><span class="line">ID=&quot;centos&quot;</span><br><span class="line">ID_LIKE=&quot;rhel fedora&quot;</span><br><span class="line">VERSION_ID=&quot;7&quot;</span><br><span class="line">PRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;</span><br><span class="line">ANSI_COLOR=&quot;0;31&quot;</span><br><span class="line">CPE_NAME=&quot;cpe:/o:centos:centos:7&quot;</span><br><span class="line">HOME_URL=&quot;https://www.centos.org/&quot;</span><br><span class="line">BUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;</span><br><span class="line"></span><br><span class="line">CENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;</span><br><span class="line">CENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT=&quot;centos&quot;</span><br><span class="line">REDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>安装</p>
</blockquote>
<p>帮助文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/engine/install/">https://docs.docker.com/engine/install/</a><br>卸载与安装</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.卸载旧版本</span></span><br><span class="line">yum remove docker \</span><br><span class="line">                  docker-client \</span><br><span class="line">                  docker-client-latest \</span><br><span class="line">                  docker-common \</span><br><span class="line">                  docker-latest \</span><br><span class="line">                  docker-latest-logrotate \</span><br><span class="line">                  docker-logrotate \</span><br><span class="line">                  docker-engine</span><br><span class="line"><span class="meta">#</span><span class="bash">2.需要的安装包</span></span><br><span class="line">yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3.设置镜像的仓库</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br><span class="line"><span class="meta">#</span><span class="bash">上述方法默认是从国外的，不推荐</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">推荐使用国内的</span></span><br><span class="line">yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">更新yum软件包索引</span></span><br><span class="line">yum makecache fast</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4.安装docker相关的 docker-ce 社区版 而ee是企业版</span></span><br><span class="line">yum install docker-ce docker-ce-cli containerd.io # 这里我们使用社区版即可</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">5.启动docker</span></span><br><span class="line">systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">6. 使用docker version查看是否按照成功</span></span><br><span class="line">docker version</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">7. 测试</span></span><br><span class="line">docker run hello-world</span><br><span class="line">12345678910111213141516171819202122232425262728293031323334353637</span><br><span class="line"><span class="meta">#</span><span class="bash">8.查看已经下载的镜像(从这里可以查看已有镜像的id)</span></span><br><span class="line">[root@iz2zeak7sgj6i7hrb2g862z ~]# docker images</span><br><span class="line">REPOSITORY            TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hello-world           latest              bf756fb1ae65        4 months ago      13.3kB</span><br></pre></td></tr></table></figure>

<p>卸载docker</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1. 卸载依赖</span></span><br><span class="line">yum remove docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash">2. 删除资源</span></span><br><span class="line">rm -rf /var/lib/docker</span><br><span class="line"><span class="meta">#</span><span class="bash"> /var/lib/docker 是docker的默认工作路径！</span></span><br></pre></td></tr></table></figure>

<h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><h4 id="1、登录阿里云找到容器服务"><a href="#1、登录阿里云找到容器服务" class="headerlink" title="1、登录阿里云找到容器服务"></a>1、登录阿里云找到容器服务</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjExMjg1MS5wbmc?x-oss-process=image/format,png" alt="image-20200515102112851"></p>
<h4 id="2、找到镜像加速器"><a href="#2、找到镜像加速器" class="headerlink" title="2、找到镜像加速器"></a>2、找到镜像加速器</h4><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjAwOTQ3MC5wbmc?x-oss-process=image/format,png" alt="image-20200515102009470"></p>
<h4 id="3、配置使用"><a href="#3、配置使用" class="headerlink" title="3、配置使用"></a>3、配置使用</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.创建一个目录</span></span><br><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.编写配置文件</span></span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&#x27;EOF&#x27;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://t2wwyxhb.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3.重启服务</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>

<h1 id="回顾HelloWorld流程"><a href="#回顾HelloWorld流程" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h1><h3 id="回顾HelloWorld流程-1"><a href="#回顾HelloWorld流程-1" class="headerlink" title="回顾HelloWorld流程"></a>回顾HelloWorld流程</h3><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjUwMzcyMi5wbmc?x-oss-process=image/format,png" alt="image-20200515102503722"></p>
<p><strong>docker run 流程图</strong></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjYzNzI0Ni5wbmc?x-oss-process=image/format,png" alt="image-20200515102637246"></p>
<h4 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h4><p>Docker<strong>是怎么工作的</strong>？</p>
<p>Docker是一个Client-Server结构的系统，Docker的守护进程运行在主机上。通过Socket从客户端访问！</p>
<p>Docker-Server接收到Docker-Client的指令，就会执行这个命令！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwMjk0OTU1OC5wbmc?x-oss-process=image/format,png" alt="image-20200515102949558"></p>
<p><strong>为什么Docker比Vm快</strong><br>1、docker有着比虚拟机更少的抽象层。由于docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。<br>2、docker利用的是宿主机的内核,而不需要Guest OS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GuestOS： VM（虚拟机）里的的系统（OS）</span><br><span class="line"></span><br><span class="line">HostOS：物理机里的系统（OS）</span><br></pre></td></tr></table></figure>

<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTEwNDExNzMyOS5wbmc?x-oss-process=image/format,png" alt="image-20200515104117329"></p>
<p>因此,当新建一个 容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引导、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载GuestOS,返个新建过程是<strong>分钟级别</strong>的。而docker由于直接利用宿主机的操作系统,则省略了这个复杂的过程,因此新建一个docker容器只需要<strong>几秒钟</strong>。</p>
<h1 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h1><h3 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker version       		#显示docker的版本信息。</span><br><span class="line">docker info					#显示docker的系统信息，包括镜像和容器的数量</span><br><span class="line">docker 命令 --help		   #帮助命令</span><br></pre></td></tr></table></figure>



<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker images #查看所有本地主机上的镜像 可以使用docker image ls代替</span><br><span class="line"></span><br><span class="line">docker search #搜索镜像</span><br><span class="line"></span><br><span class="line">docker pull #下载镜像 docker image pull</span><br><span class="line"></span><br><span class="line">docker rmi #删除镜像 docker image rm</span><br></pre></td></tr></table></figure>



<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><p><strong>说明：我们有了镜像才可以创建容器，linux，下载一个centos镜像来测试学习</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull centos </span><br></pre></td></tr></table></figure>

<p><strong>新建一个容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">参数说明</span></span><br><span class="line">-- name=&quot;Name&quot;  容器名字 tomcat01 tomcat02 用来区分容器</span><br><span class="line">-d 			后台方式运行</span><br><span class="line">-it			使用交互方式运行，进入容器查看内容</span><br><span class="line">-P			指定容器的端口</span><br><span class="line">	-p  ip:主机端口:容器端口</span><br><span class="line">	-p	主机端口:容器端口(常用)</span><br><span class="line">	-p	容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-p			随机指定端口</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#测试，启动并进入容器</span></span></span><br><span class="line">[root@Timor /]# docker run -it centos /bin/bash</span><br><span class="line">[root@00286c5eb25b /]# ls</span><br><span class="line">bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var</span><br><span class="line">[root@00286c5eb25b /]# exit</span><br><span class="line">exit</span><br><span class="line">[root@Timor /]# </span><br></pre></td></tr></table></figure>



<p><strong>列出所有运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker ps 命令  		#列出当前正在运行的容器</span><br><span class="line">  -a, --all     	 #列出当前正在运行的容器 + 带出历史运行过的容器</span><br><span class="line">  -n=?, --last int   #列出最近创建的?个容器 ?为1则只列出最近创建的一个容器,为2则列出2个</span><br><span class="line">  -q, --quiet        #只列出容器的编号</span><br></pre></td></tr></table></figure>



<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">exit 		#容器直接退出</span><br><span class="line">ctrl +P +Q  #容器不停止退出 </span><br></pre></td></tr></table></figure>



<p><strong>删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker rm 容器id					#删除指定的容器，不能删除正在运行的容器  强制删除rm -f</span><br><span class="line">docker rm -f $(docker ps -aq)	 #删除所有的容器</span><br><span class="line">docker ps -a -q|xargs docker rm  #删除所有的容器</span><br></pre></td></tr></table></figure>



<p><strong>启动和停止容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id		#停止</span><br><span class="line">docker kill 容器id		#强制停止</span><br></pre></td></tr></table></figure>



<h3 id="常用其他命令"><a href="#常用其他命令" class="headerlink" title="常用其他命令"></a>常用其他命令</h3><p><strong>后台启动容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令 docker run -d 镜像名</span></span><br><span class="line">[root@Timor /]# docker run -d centos</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">问题 docker ps 发现centos停止了</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">常见的坑:docker 容器使用后台运行，就必须要有一个前台进程，docker发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta">#</span><span class="bash">nginx，容器启动后发现自己没有提供服务，就会立即停止</span></span><br></pre></td></tr></table></figure>

<p><strong>查看日志</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">docker logs</span><br><span class="line"></span><br><span class="line">[root@Timor /]# docker logs -f -t --tail 10 d5138a676ae6</span><br><span class="line">2020-12-04T15:30:35.984438844Z [root@d5138a676ae6 /]# docker ps</span><br><span class="line">2020-12-04T15:30:35.984513104Z bash: docker: command not found</span><br></pre></td></tr></table></figure>

<p><strong>查看容器中的进程信息</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令 docker top 容器id</span></span><br><span class="line"></span><br><span class="line">[root@Timor /]# docker top d5138a676ae6 </span><br><span class="line">UID                 PID                 PPID                C                   STIME               TTY     </span><br><span class="line">root                20418               20400               0                   23:30               ?      </span><br></pre></td></tr></table></figure>

<p><strong>查看镜像源数据</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">命令 docker inspect 容器id</span></span><br><span class="line"></span><br><span class="line">[root@Timor /]# docker inspect d5138a676ae6</span><br></pre></td></tr></table></figure>

<p><strong>进入当前正在运行的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 命令一</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line">[root@Timor /]# docker exec -it d5138a676ae6 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">命令二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line">[root@Timor /]# docker attach d5138a676ae6</span><br><span class="line">正在执行当期的代码。。。。</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">docker <span class="built_in">exec</span>		<span class="comment">#进入容器后开启一个新的终端，可以在里面操作（常用）</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">docker attach		<span class="comment">#进入容器正在执行的终端，不会启动新的进程</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><strong>从容器内拷贝文件到主机上</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker cp 容器id:容器内路径	目的主机路径</span><br><span class="line"></span><br><span class="line">[root@Timor home]# docker cp d5138a676ae6:/home/test.java /home</span><br><span class="line">[root@Timor home]# ls</span><br><span class="line">beihe  redis  test.java  timor  www</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">拷贝是一个手动过程，未来我们采用-v卷的技术，可以实现自动同步</span></span><br></pre></td></tr></table></figure>



<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a><strong>小结</strong></h3><p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201205215255186.png" alt="image-20201205215255186"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line"><span class="meta">#</span><span class="bash">当前shell下 attach连接指定运行的镜像</span></span><br><span class="line">build       Build an image from a Dockerfile # 通过Dockerfile定制镜像</span><br><span class="line">commit      Create a new image from a container&#x27;s changes #提交当前容器为新的镜像</span><br><span class="line">cp          Copy files/folders between a container and the local filesystem #拷贝文件</span><br><span class="line">create      Create a new container #创建一个新的容器</span><br><span class="line">diff        Inspect changes to files or directories on a container&#x27;s filesystem #查看docker容器的变化</span><br><span class="line">events      Get real time events from the server # 从服务获取容器实时时间</span><br><span class="line">exec        Run a command in a running container # 在运行中的容器上运行命令</span><br><span class="line">export      Export a container&#x27;s filesystem as a tar archive #导出容器文件系统作为一个tar归档文件[对应import]</span><br><span class="line">history     Show the history of an image # 展示一个镜像形成历史</span><br><span class="line">images      List images #列出系统当前的镜像</span><br><span class="line">import      Import the contents from a tarball to create a filesystem image #从tar包中导入内容创建一个文件系统镜像</span><br><span class="line">info        Display system-wide information # 显示全系统信息</span><br><span class="line">inspect     Return low-level information on Docker objects #查看容器详细信息</span><br><span class="line">kill        Kill one or more running containers # kill指定docker容器</span><br><span class="line">load        Load an image from a tar archive or STDIN #从一个tar包或标准输入中加载一个镜像[对应save]</span><br><span class="line">login       Log in to a Docker registry #</span><br><span class="line">logout      Log out from a Docker registry</span><br><span class="line">logs        Fetch the logs of a container</span><br><span class="line">pause       Pause all processes within one or more containers</span><br><span class="line">port        List port mappings or a specific mapping for the container</span><br><span class="line">ps          List containers</span><br><span class="line">pull        Pull an image or a repository from a registry</span><br><span class="line">push        Push an image or a repository to a registry</span><br><span class="line">rename      Rename a container</span><br><span class="line">restart     Restart one or more containers</span><br><span class="line">rm          Remove one or more containers</span><br><span class="line">rmi         Remove one or more images</span><br><span class="line">run         Run a command in a new container</span><br><span class="line">save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">search      Search the Docker Hub for images</span><br><span class="line">start       Start one or more stopped containers</span><br><span class="line">stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">stop        Stop one or more running containers</span><br><span class="line">tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">top         Display the running processes of a container</span><br><span class="line">unpause     Unpause all processes within one or more containers</span><br><span class="line">update      Update configuration of one or more containers</span><br><span class="line">version     Show the Docker version information</span><br><span class="line">wait        Block until one or more containers stop, then print their exit codes</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="作业练习"><a href="#作业练习" class="headerlink" title="作业练习"></a>作业练习</h3><blockquote>
<p>Docker 安装 Nginx</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1.搜索镜像</span></span><br><span class="line">docker search nignx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2.下载镜像</span></span><br><span class="line">docker pull nignx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3，查看镜像</span></span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">4.启动镜像    （-d 代表后台运行）</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">-d 代表后台运行</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">--name 给容器命名</span></span><br><span class="line"><span class="meta">	#</span><span class="bash">-p 宿主机端口，容器内部端口</span></span><br><span class="line">[root@Timor /]# docker run -d --name nginx01 -p:3344:80 nginx</span><br><span class="line"></span><br><span class="line">[root@Timor /]# docker ps</span><br><span class="line"></span><br><span class="line">[root@Timor /]# curl localhost:3344</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">[root@Timor /]# docker exec -it nginx01 /bin/bash</span><br><span class="line">root@1410705ee117:/# whereis nginx</span><br><span class="line">nginx: /usr/sbin/nginx /usr/lib/nginx /etc/nginx /usr/share/nginx</span><br><span class="line">root@1410705ee117:/# cd /etc/nginx</span><br><span class="line">root@1410705ee117:/etc/nginx# ls</span><br><span class="line">conf.d	fastcgi_params	koi-utf  koi-win  mime.types  modules  nginx.conf  scgi_params	uwsgi_params  win-utf</span><br></pre></td></tr></table></figure>

<p><strong>问题</strong>：难道每次改动 nginx 配置文件，都需要进入容器内部改动吗？那岂不是非常的麻烦，如果能够在容器外部提供一个映射路径，做到在容器外部修改文件，容器内部就能够自动修改，这样就非常方便了。这就是之后要学的卷技术</p>
<blockquote>
<p>作业：docker 安装一个tomcat</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">官方的使用</span></span><br><span class="line">docker run -it --rm tomcat:9.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">我们之前的启动都是后台，停止了容器之后，容器还是可以查到  </span></span><br><span class="line">docker run -it --rm 一般用来测试，用完即删</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">下载再启动</span></span><br><span class="line">docker pull tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动运行</span></span><br><span class="line">[root@Timor /]# docker run -d -p 3355:8080 --name tomcat01 tomcat</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">测试访问没有问题</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">进入容器</span></span><br><span class="line">[root@Timor /]# docker exec -it tomcat01 /bin/bash</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">发现问题：1.linux命令少了 2.没有webapps	阿里云镜像的原因，默认是最小的镜像，剔除所有不必要的</span></span><br><span class="line"><span class="meta">#</span><span class="bash">保证最小的可运行的环境</span></span><br><span class="line"></span><br><span class="line">root@a22718fde3e6:/usr/local/tomcat# cp -r webapps.dist/* webapps</span><br></pre></td></tr></table></figure>



<blockquote>
<p>作业：部署es + kibana</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">es 暴露的端口很多</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es 耗内存</span></span><br><span class="line"><span class="meta">#</span><span class="bash">es 数据一般需要放置到安全目录 挂载</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --net somenetwork 网络配置</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动 elasticsearch</span></span><br><span class="line"> docker run -d --name elasticsearch  -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="meta">#</span><span class="bash">限制内存配置</span></span><br><span class="line"> docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; -e </span><br><span class="line"> ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot;  elasticsearch:7.6.2</span><br><span class="line"> </span><br></pre></td></tr></table></figure>



<h3 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h3><ul>
<li>portainer(先用这个)</li>
</ul>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<ul>
<li>Rancher(CI/CD再用)</li>
</ul>
<p><strong>什么是portainer？</strong></p>
<p>Docker图形化界面管理工具！提供一个后台面板供我们操作！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 8088:9000 \</span><br><span class="line">--restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br></pre></td></tr></table></figure>

<p>测试访问： 外网：8088</p>
<h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h3 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h3><p>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，他包含运行某个软件所需的所有内容，包括代码、运行时库、环境变量和配置文件。</p>
<p>所有的应用，直接打包docker镜像，就可以直接跑起来。</p>
<h3 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a><strong>Docker镜像加载原理</strong></h3><blockquote>
<p>UnionFS （联合文件系统）</p>
</blockquote>
<p>UnionFS（联合文件系统）：Union文件系统（UnionFS）是一种分层、轻量级并且高性能的文件系统，他支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下（ unite several directories into a single virtual filesystem)。Union文件系统是 Docker镜像的基础。镜像可以通过分层来进行继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像<br>特性：一次同时加载多个文件系统，但从外面看起来，只能看到一个文件系统，联合加载会把各层文件系统叠加起来，这样最终的文件系统会包含所有底层的文件和目录</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。<br>bootfs(boot file system）主要包含 bootloader和 Kernel, bootloader主要是引导加 kernel, Linux刚启动时会加bootfs文件系统，在 Docker镜像的最底层是 boots。这一层与我们典型的Linux/Unix系统是一样的，包含boot加載器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由 bootfs转交给内核，此时系统也会卸载bootfs。<br>rootfs（root file system),在 bootfs之上。包含的就是典型 Linux系统中的/dev,/proc,/bin,/etc等标准目录和文件。 rootfs就是各种不同的操作系统发行版，比如 Ubuntu, Centos等等。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzA0OTk1OS5wbmc?x-oss-process=image/format,png" alt="image-20200515163049959"></p>
<p>平时我们安装进虚拟机的CentOS都是好几个G，为什么Docker这里才200M？</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MzE0MDU1OS5wbmc?x-oss-process=image/format,png" alt="image-20200515163140559"></p>
<p>对于个精简的OS,rootfs可以很小，只需要包合最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs就可以了。由此可见对于不同的Linux发行版， bootfs基本是一致的， rootfs会有差別，因此不同的发行版可以公用bootfs.</p>
<p>虚拟机是分钟级别，容器是秒级！</p>
<h3 id="分层理解"><a href="#分层理解" class="headerlink" title="分层理解"></a>分层理解</h3><blockquote>
<p>分层的镜像</p>
</blockquote>
<p>我们可以去下载一个镜像，注意观察下载的日志输出，可以看到是一层层的在下载</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201207171410460.png" alt="image-20201207171410460"></p>
<p>思考：为什么Docker镜像要采用这种分层的结构呢？</p>
<p>最大的好处，我觉得莫过于资源共享了！比如有多个镜像都从相同的Base镜像构建而来，那么宿主机只需在磁盘上保留一份base镜像，同时内存中也只需要加载一份base镜像，这样就可以为所有的容器服务了，而且镜像的每一层都可以被共享。</p>
<p>查看镜像分层的方式可以通过docker image inspect 命令</p>
<p><strong>理解：</strong></p>
<p>所有的 Docker镜像都起始于一个基础镜像层，当进行修改或培加新的内容时，就会在当前镜像层之上，创建新的镜像层。</p>
<p>举一个简单的例子，假如基于 Ubuntu Linux16.04创建一个新的镜像，这就是新镜像的第一层；如果在该镜像中添加 Python包，<br>就会在基础镜像层之上创建第二个镜像层；如果继续添加一个安全补丁，就会创健第三个镜像层该像当前已经包含3个镜像层，如下图所示（这只是一个用于演示的很简单的例子）。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTIzNDI3NC5wbmc?x-oss-process=image/format,png" alt="img"></p>
<p><strong>在添加额外的镜像层的同时，镜像始终保持是当前所有镜像的组合，理解这一点非常重要。</strong>下图中举了一个简单的例子，每个镜像层包含3个文件，而镜像包含了来自两个镜像层的6个文件。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NDk1ODkzMi5wbmc?x-oss-process=image/format,png" alt="image-20200515164958932"></p>
<p>上图中的镜像层跟之前图中的略有区別，主要目的是便于展示文件<br>下图中展示了一个稍微复杂的三层镜像，在外部看来整个镜像只有6个文件，这是因为最上层中的文件7是文件5的一个更新版</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTE0ODAwMi5wbmc?x-oss-process=image/format,png" alt="image-20200515165148002"></p>
<p>文种情況下，上层镜像层中的文件覆盖了底层镜像层中的文件。这样就使得文件的更新版本作为一个新镜像层添加到镜像当中</p>
<p>Docker通过存储引擎（新版本采用快照机制）的方式来实现镜像层堆栈，并保证多镜像层对外展示为统一的文件系统</p>
<p>Linux上可用的存储引撃有AUFS、 Overlay2、 Device Mapper、Btrfs以及ZFS。顾名思义，每种存储引擎都基于 Linux中对应的<br>件系统或者块设备技术，井且每种存储引擎都有其独有的性能特点。</p>
<p>Docker在 Windows上仅支持 windowsfilter 一种存储引擎，该引擎基于NTFS文件系统之上实现了分层和CoW [1]。</p>
<p>下图展示了与系统显示相同的三层镜像。所有镜像层堆并合井，对外提供统一的视图</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2NTU1NzgwNy5wbmc?x-oss-process=image/format,png" alt="image-20200515165557807"></p>
<blockquote>
<p>特点</p>
</blockquote>
<p>Docker 镜像都是只读的，当容器启动时，一 个新的可写层加载到镜像的顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNTE2MTUwNTg5Ny5wbmc?x-oss-process=image/format,png" alt="image-20200515161505897"></p>
<p>如何提交一个自己的镜像</p>
<h3 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker commit 提交容器称为一个新的副本</span><br><span class="line"></span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id  目标镜像名:[TAG]</span><br></pre></td></tr></table></figure>

<p>实战测试</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1、启动一个默认的tomcat</span></span><br><span class="line">docker run -d -p 8080:8080 tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 2、发现这个默认的tomcat 是没有webapps应用，官方的镜像默认webapps下面是没有文件的！</span></span><br><span class="line">docker exec -it 容器id</span><br><span class="line"><span class="meta">#</span><span class="bash"> 3、拷贝文件进去</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4、将操作过的容器通过commit调教为一个镜像！我们以后就使用我们 修改过的镜像即可，这就是我们自己的一个修改的镜像。</span></span><br><span class="line">docker commit -m=&quot;描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[TAG]</span><br><span class="line"></span><br><span class="line">docker commit -a=&quot;kuangshen&quot; -m=&quot;add webapps app&quot; 容器id tomcat02:1.0</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201207220940061.png" alt="image-20201207220940061"></p>
<p>如果你想要保存当前容器的状态，就可以通过commit来提交，获得一个镜像，就好比我们我们使用虚拟机的快照。</p>
<h1 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h1><h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p><strong>docker的理念回顾</strong></p>
<p>将应用和环境打包成一个镜像！</p>
<p>数据？如果数据都在容器中，那么我们容器删除，数据就会丢失！需求：数据可以持久化</p>
<p>MySQL，容器删除了，删库跑路！需求：MySQL数据可以存储在本地！</p>
<p>容器之间可以有一个数据共享的技术！Docker容器中产生的数据，同步到本地！</p>
<p>这就是卷技术！目录的挂载，将我们容器内的目录，挂载到Linux上面！</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201208114036868.png" alt="image-20201208114036868"></p>
<p><strong>总结一句话：容器的持久化和同步操作！容器间也是可以数据共享的！</strong></p>
<h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h3><blockquote>
<p>方式一 : 直接使用命令来挂载  -v</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it -v 主机目录:容器内目录</span><br><span class="line"></span><br><span class="line">[root@Timor home]# docker run -it -v /home/test:/home centos /bin/bash</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201208115632914.png" alt="image-20201208115632914"></p>
<h3 id="实战：安装MYSQL"><a href="#实战：安装MYSQL" class="headerlink" title="实战：安装MYSQL"></a>实战：安装MYSQL</h3><p>思考：MYSQL的数据持久化的问题</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker search mysql</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取镜像</span></span><br><span class="line">docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">运行容器，需要做数据挂载！  <span class="comment">#安装启动mysql，需要配置密码</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">$ docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag</span></span><br><span class="line"></span><br><span class="line">[root@Timor /]# docker run -d -p 3310:3306 -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 --name mysql01 mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">启动成功之后本地连接测试成功</span></span><br></pre></td></tr></table></figure>



<h3 id="具名挂载和匿名挂载"><a href="#具名挂载和匿名挂载" class="headerlink" title="具名挂载和匿名挂载"></a>具名挂载和匿名挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 匿名挂载</span></span><br><span class="line">-v 容器内路径!</span><br><span class="line">docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有的volume的情况</span></span><br><span class="line">➜  ~ docker volume ls    </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               33ae588fae6d34f511a769948f0d3d123c9d45c442ac7728cb85599c2657e50d   </span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里发现，这种就是匿名挂载，我们在 -v只写了容器内的路径，没有写容器外的路劲！</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 具名挂载</span></span><br><span class="line">➜  ~ docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx nginx</span><br><span class="line">➜  ~ docker volume ls                  </span><br><span class="line">DRIVER              VOLUME NAME</span><br><span class="line">local               juming-nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 卷名：容器内路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看一下这个卷</span></span><br><span class="line">docker volume inspect juming-nginx</span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201208220019681.png" alt="image-20201208220019681"></p>
<p>所有的docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes/xxxx/_data</code>下<br>如果指定了目录，docker volume ls 是查看不到的 </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 三种挂载： 匿名挂载、具名挂载、指定路径挂载</span></span><br><span class="line">-v 容器内路径			#匿名挂载</span><br><span class="line">-v 卷名：容器内路径		#具名挂载</span><br><span class="line">-v /宿主机路径：容器内路径 #指定路径挂载 docker volume ls 是查看不到的</span><br></pre></td></tr></table></figure>

<p>扩展</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 通过 -v 容器内路径： ro rw 改变读写权限</span></span><br><span class="line">ro #readonly 只读</span><br><span class="line">rw #readwrite 可读可写 </span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:ro nginx</span><br><span class="line">docker run -d -P --name nginx05 -v juming:/etc/nginx:rw nginx</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作！</span></span><br></pre></td></tr></table></figure>



<h3 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h3><p>Dockerfile 就是用来构建docker 镜像的构建文件！命令脚本！</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本的一个个命令，每个命令都是一层！</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建一个dockerfile文件，名字可以随便 建议Dockerfile</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件中的内容 指令(大写) 参数</span></span><br><span class="line">FROM centos</span><br><span class="line"></span><br><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]</span><br><span class="line"></span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash">这里的每个命令，就是镜像的一层！</span></span><br></pre></td></tr></table></figure>



<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">构建镜像</span></span><br><span class="line">[root@Timor docker-test-volume]# docker build -f /home/docker-test-volume/dockerfile1  -t kuangshen/centos:1.0 . </span><br></pre></td></tr></table></figure>

<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201217204414710.png" alt="image-20201217204414710"></p>
<p> <img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201217204657402.png" alt="image-20201217204657402"></p>
<p>启动容器，发现这两个目录是我们生成目录的时候自动挂载的，即数据卷目录</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201217205030761.png" alt="image-20201217205030761"></p>
<p><strong>这个卷一定和外部有一个同步的目录</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">VOLUME [&quot;volume01&quot;,&quot;volume02&quot;]     #匿名挂载</span><br></pre></td></tr></table></figure>

<p>查看一下卷挂载路径</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201217205848898.png" alt="image-20201217205848898"></p>
<p>这种方式使用的十分多，因为我们通常会构建自己的镜像！</p>
<p>假设构建镜像时候没有挂载卷，要手动镜像挂载 -v 卷名：容器内路径！</p>
<h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p>多个mysql同步数据！</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9yYXcuZ2l0aHVidXNlcmNvbnRlbnQuY29tL2NoZW5nY29kZXgvY2xvdWRpbWcvbWFzdGVyL2ltZy9pbWFnZS0yMDIwMDUxNjEyMjA0NzQ0MC5wbmc?x-oss-process=image/format,png" alt="image-20200516122047440"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--volumes-from list              Mount volumes from the specified container(s)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 测试，我们通过刚才启动的</span></span><br></pre></td></tr></table></figure>



















<h1 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h1><h1 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h1>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/angular/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/angular/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-21 13:47:09" itemprop="dateModified" datetime="2020-07-21T13:47:09+08:00">2020-07-21</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>当网页加载完毕，AngularJS 自动开启。</p>
<p><strong>ng-app</strong> 指令告诉 AngularJS，<div> 元素是 AngularJS <strong>应用程序</strong> 的”所有者”。</p>
<p><strong>ng-model</strong> 指令把输入域的值绑定到应用程序变量 <strong>name</strong>。</p>
<p><strong>ng-bind</strong> 指令把应用程序变量 name 绑定到某个段落的 innerHTML。</p>
<h4 id="脏检查"><a href="#脏检查" class="headerlink" title="脏检查"></a>脏检查</h4><ul>
<li><p>$apply仅仅只是进入angular context，然后通过$digest去触发脏检查</p>
</li>
<li><p>$apply如果不给参数的话，会检查该$scope里的所有监听的属性，推荐给上参数</p>
<h5 id="digest"><a href="#digest" class="headerlink" title="$digest"></a>$digest</h5></li>
<li><p>所属的scope和其所有子scope的脏检查，脏检查又会触发$watch(),整个Angular双向绑定机制就活了起来</p>
</li>
<li><p>不建议直接调用$digest(),而应该使用$apply.</p>
</li>
</ul>
<h4 id="定义服务-provider"><a href="#定义服务-provider" class="headerlink" title="定义服务$provider"></a>定义服务$provider</h4><ul>
<li>服务本身是一个任意的对象</li>
<li>ng提供服务的过程涉及它的依赖注入机制</li>
<li>angular是用$provider对象来实现自动依赖注入机制，注入机制通过调用一个provider的$get()方法，把对象作为参数进行相关调用</li>
<li>$provider.provider是一种定义服务的方法,$provider还提供了很多简便的方法，这些简便的方法还直接被module所引用。</li>
</ul>
<h4 id="provider-factory"><a href="#provider-factory" class="headerlink" title="$provider.factory"></a>$provider.factory</h4><ul>
<li>factory方法直接把一个函数当成是一个对象的$get()方法</li>
<li>@see module.factory</li>
<li>返回的内容可以是任何内容</li>
</ul>
<h4 id="过滤器种类"><a href="#过滤器种类" class="headerlink" title="过滤器种类"></a>过滤器种类</h4><ul>
<li><p>number</p>
</li>
<li><p>currency</p>
</li>
<li><p>date</p>
<p>date : ‘y-M-d H-m-s’</p>
</li>
<li><p>json</p>
</li>
<li><p>limitTo</p>
</li>
<li><p>lowercase</p>
</li>
<li><p>uppercase</p>
</li>
<li><p>filter(string|function|object)</p>
<p>只能匹配value值，不能匹配key值</p>
</li>
<li><p>number</p>
</li>
<li><p>orderBy(string|function|object)</p>
</li>
</ul>
<h4 id="内置指令"><a href="#内置指令" class="headerlink" title="内置指令"></a>内置指令</h4><ol>
<li><p>渲染指令</p>
<ul>
<li><p>ng-init</p>
</li>
<li><p>ng-bind</p>
</li>
<li><p>ng-repeat</p>
<p>$index 当前索引</p>
<p>$first 是否为头元素</p>
<p>$middle 是否为非头非尾元素</p>
<p>$last是否为尾元素</p>
</li>
<li><p>ng-include </p>
</li>
<li><p>ng-bind-template </p>
</li>
</ul>
</li>
<li><p>事件指令</p>
<ul>
<li>ng-change</li>
<li>ng-click</li>
<li>ng-dbclick</li>
<li>ng-mousedown</li>
<li>ng-mouseenter</li>
<li>ng-mouseleaver</li>
<li>ng-mousemove</li>
<li>ng-mouseover</li>
<li>ng-mouseup</li>
<li>ng-submit</li>
</ul>
</li>
<li><p>节点指令</p>
<ul>
<li>ng-style</li>
<li>ng-class</li>
<li>ng-class-even</li>
<li>ng-class-odd</li>
<li>ng-show</li>
<li>ng-hide</li>
<li>ng-switch</li>
<li>ng-src </li>
<li>ng-href</li>
<li>ng-if</li>
</ul>
</li>
</ol>
<h4 id="自定义指令"><a href="#自定义指令" class="headerlink" title="自定义指令"></a>自定义指令</h4><p>指令的定义</p>
<ul>
<li>module.directive(name,directiveFactory)</li>
<li>@see $complileProvider.directive()</li>
</ul>
<p>restrict、template、replace</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20200716164552676.png" alt="image-20200716164552676"></p>
<h5 id="template"><a href="#template" class="headerlink" title="template"></a>template</h5><p>template:模板内容，这个内容会根据replace参数的设置替换节点或只替换节点内容。</p>
<img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20200716171419476.png" alt="image-20200716171419476" style="zoom:67%;" />

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myApp = angular.module(<span class="string">&#x27;myApp&#x27;</span>, [], [<span class="string">&#x27;$compileProvider&#x27;</span>,<span class="function"><span class="keyword">function</span> (<span class="params">$compileProvider</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">    $compileProvider.directive(<span class="string">&#x27;customTags&#x27;</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            restrict:<span class="string">&#x27;ECAM&#x27;</span>,</span><br><span class="line">            template:<span class="string">&#x27;&lt;div&gt;custom-tags-html&lt;/div&gt;&#x27;</span>,</span><br><span class="line">            replace:<span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">&#125;])</span><br></pre></td></tr></table></figure>

<h4 id="templateUrl"><a href="#templateUrl" class="headerlink" title="templateUrl"></a>templateUrl</h4><ul>
<li><p>templateUrl:加载模板所要使用的URL</p>
</li>
<li><p>可以加载当前模板内对应的text/ng-template script id</p>
</li>
<li><p>在使用Chrome浏览器时，”同源策略“会阻止Chrome从file://中加载模板，并显示一个</p>
<p>“Access-Control-Allow-Orgin”不允许源为null，可以把项目放在服务器上加载，或者给</p>
<p>chrome设置一个标志，命令为:chrome -allow-file-access-from-files</p>
</li>
</ul>
<h4 id="transclude"><a href="#transclude" class="headerlink" title="transclude"></a>transclude</h4><ul>
<li><p>transclude:指令元素中的原来的子节点移动到一个新模板内部</p>
</li>
<li><p>当为true时，指令会删去原来的内容，使你的模板可以用ng-transclude指令进行重新插入</p>
</li>
<li><pre><code class="js">.directive(&#39;customTags&#39;, function () &#123;
    return &#123;
        restrict: &#39;ECAM&#39;,
        template:&#39;&lt;div&gt;新数据 &lt;span ng-transclude&gt;&lt;/span&gt;&lt;/div&gt;&#39;,
        replace: true,
        transclude:true
    &#125;
&#125;)</code></pre>
</li>
</ul>
<h4 id="priority-terminal"><a href="#priority-terminal" class="headerlink" title="priority$$terminal"></a>priority$$terminal</h4><ul>
<li><p>priority: 设置指令在模板中的执行顺序，顺序是相对于元素上其他执行而言，默认为0，从大到小的顺序依次执行</p>
</li>
<li><p>设置优先级的情况比较少，像ng-repeat,在遍历元素的过程中，需要angular先拷贝生成的模板元素，再应用其他指令，所以ng-repeat默认的priority是1000</p>
</li>
<li><p>terminal是否以当前指令的权重为结束界限。如果这值设置为true，则节点中权重小于当前指令的其他指令不会被执行。相同权重的会执行。 </p>
</li>
</ul>
<p>Angular.js编译三阶段</p>
<p>1.标准浏览器API转化</p>
<p>​     将html转化成dom,所以自定义的html标签必须符合html的格式</p>
<p>2.Angular complie</p>
<p>​    搜索匹配directive,按照priority排序，并执行directive上的compile方法</p>
<p>3.Angular link</p>
<p>​    执行directive上的link方法，进行scope绑定及事件绑定</p>
<h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><ul>
<li>compile:function(tElement,tAttrs,transclude)</li>
<li>complie函数用来对模板自身进行转换，仅仅在编译阶段运行一次</li>
<li>compile中直接返回的函数是postLink，表示link参数需要执行的函数，也可以返回一个对象里面包含preLink和postLink</li>
<li>当定义compile参数时，将无视link参数，因为compile里返回的就是该指令需要执行的link函数</li>
</ul>
<h5 id="controller-amp-amp-controllerAs-amp-amp-require"><a href="#controller-amp-amp-controllerAs-amp-amp-require" class="headerlink" title="controller&amp;&amp;controllerAs&amp;&amp;require"></a>controller&amp;&amp;controllerAs&amp;&amp;require</h5><ul>
<li><p>controller 会暴露一个API，利用这个API可以在多个指令之间通过依赖注入进行通信</p>
</li>
<li><p>controller（$scope,$element,$attrs,$transclude)</p>
</li>
<li><p>controllerAs 是给controller起个别名，方便使用</p>
</li>
<li><p>require可以将其他指令传给自己</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20200717163343528.png" alt="image-20200717163343528"></p>
</li>
</ul>
<h3 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h3><ul>
<li>scope 为当前指令创建一个新的作用域，而不是使之继承父作用域</li>
<li>false 继承父元素的作用域 </li>
<li>true 创建一个新的作用域</li>
<li>object 独立的scope</li>
</ul>
<p>*object 参数</p>
<p>&amp;：作用域把父作用域的属性包装成一个函数，从而以函数的方式读写父作用域的属性</p>
<p>=：作用域的属性与父作用域的属性进行双向绑定，任何一方的修改均影响到对方</p>
<p>@：只能读取父作用域里的值单向绑定</p>
<h2 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h2><p>一般来说表单可能遇到的问题</p>
<ol>
<li>如何数据绑定</li>
<li>验证表单</li>
<li>显示出错信息</li>
<li>整个Form的验证</li>
<li>避免提交没有验证通过的表单</li>
<li>防止多次提交</li>
</ol>
<h4 id="input属性"><a href="#input属性" class="headerlink" title="input属性"></a>input属性</h4><ul>
<li>name 名字   </li>
<li>ng-model 绑定的数据</li>
<li>ng-required 是否必填</li>
<li>ng-minlength 最小长度</li>
<li>ng-maxlength 最大长度</li>
<li>ng-pattern 匹配模式</li>
<li>ng-change 值变化时的回调</li>
</ul>
<h4 id="Form控制变量"><a href="#Form控制变量" class="headerlink" title="Form控制变量"></a>Form控制变量</h4><ul>
<li><p>字段是否未更改</p>
<p>formName.inputFieldName.$pristine</p>
</li>
<li><p>字段是否更改</p>
<p>formName.inputFieldName.$dirty</p>
</li>
<li><p>字段有效</p>
<p>formName.inputFieldName.$valid</p>
</li>
<li><p>字段无效 </p>
<p>formName.inputFieldName.$invalid</p>
</li>
<li><p>字段错误信息 </p>
<p>formName.inputFieldName.$error</p>
</li>
</ul>
<h4 id="Form属性"><a href="#Form属性" class="headerlink" title="Form属性"></a>Form属性</h4><p>setPristine 将表单复位原始状态</p>
<h4 id="ngModel里的属性"><a href="#ngModel里的属性" class="headerlink" title="ngModel里的属性"></a>ngModel里的属性</h4><ul>
<li>$parsers属性 保存了从viewValue向modelView绑定过程中的处理函数，它们将来会依次执行</li>
<li>$formatters它保存的是从modelValue 向viewValue绑定过程中的处理函数</li>
<li>$setViewValue 当view发生了某件事情时，从view向model绑定调用$setViewValue 把viewValue保存下来</li>
<li>$render当模型发生变化时，应该怎么去更新视图，从model向view绑定，调用ctrl.$render方法，将viewValue渲染到页面上</li>
<li>$setValidity 设置验证结果</li>
<li>$viewValue() 视图的值 </li>
<li>$modelValue 模型里的值</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-02-14 22:41:18" itemprop="dateModified" datetime="2021-02-14T22:41:18+08:00">2021-02-14</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>微信小程序</p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201030113749151.png" alt="image-20201030113749151"></p>
<p> wxf48fefab77f82c75</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/vue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/vue/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-02 20:35:15" itemprop="dateModified" datetime="2021-01-02T20:35:15+08:00">2021-01-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h1><p><strong>如何拉取代码</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/hemiahwu/vue-basic/tree/master</span><br><span class="line"></span><br><span class="line">git clone https://github.com/hemiahwu/vue-basic.git</span><br><span class="line"></span><br><span class="line">git checkout lesson-1</span><br></pre></td></tr></table></figure>





<p>Vue.js 为 <code>v-on</code> 提供了<strong>事件修饰符</strong>。之前提过，修饰符是由点开头的指令后缀来表示的。</p>
<ul>
<li><code>.stop</code></li>
<li><code>.prevent</code></li>
<li><code>.capture</code></li>
<li><code>.self</code></li>
<li><code>.once</code></li>
<li><code>.passive</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 阻止单击事件继续传播 --&gt;</span><br><span class="line">&lt;a v-on:click.stop&#x3D;&quot;doThis&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 提交事件不再重载页面 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&#x3D;&quot;onSubmit&quot;&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 修饰符可以串联 --&gt;</span><br><span class="line">&lt;a v-on:click.stop.prevent&#x3D;&quot;doThat&quot;&gt;&lt;&#x2F;a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只有修饰符 --&gt;</span><br><span class="line">&lt;form v-on:submit.prevent&gt;&lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 添加事件监听器时使用事件捕获模式 --&gt;</span><br><span class="line">&lt;!-- 即内部元素触发的事件先在此处理，然后才交由内部元素进行处理 --&gt;</span><br><span class="line">&lt;div v-on:click.capture&#x3D;&quot;doThis&quot;&gt;...&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 只当在 event.target 是当前元素自身时触发处理函数 --&gt;</span><br><span class="line">&lt;!-- 即事件不是从内部元素触发的 --&gt;</span><br><span class="line">&lt;div v-on:click.self&#x3D;&quot;doThat&quot;&gt;...&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>



<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201213213955717.png" alt="image-20201213213955717"></p>
<p><strong>脚手架CLI搭建</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">全局安装 vue-cli</span></span><br><span class="line">npm install --global vue-cli</span><br><span class="line"><span class="meta">#</span><span class="bash">创建一个基于webpack模板的新项目</span></span><br><span class="line">vue init webpack my-project</span><br><span class="line"><span class="meta">#</span><span class="bash">安装依赖</span></span><br><span class="line">cd myproject</span><br><span class="line">npm install</span><br><span class="line">npm run dev</span><br></pre></td></tr></table></figure>





<p><strong>使用路由</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router --save-dev</span><br></pre></td></tr></table></figure>

<p><strong>使用resource</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-resource --save-dev</span><br></pre></td></tr></table></figure>












      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/thymeleaf/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/thymeleaf/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-12-02 11:05:57" itemprop="dateModified" datetime="2020-12-02T11:05:57+08:00">2020-12-02</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201202105458683.png" alt="image-20201202105458683"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20201202110553481.png" alt="image-20201202110553481"></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/SpringSecurity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/SpringSecurity/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-01-18 21:26:57" itemprop="dateModified" datetime="2021-01-18T21:26:57+08:00">2021-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <blockquote>
<p>权限管理是一个几乎所有后台系统都会涉及的一个重要组成部分，主要目的是对整个后台管理系统进行权限的控制，而针对的对象是员工，避免因权限控制缺失或操作不当引发的风险问题，如操作错误，数据泄露等问题。</p>
</blockquote>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20210112215612169.png" alt="image-20210112215612169"></p>
<p><strong>认证(Authentication)</strong></p>
<p>​    确认用户可以访问当前系统。</p>
<p><strong>授权(Authorization)</strong></p>
<p>​    确认用户在当前系统下所拥有的功能权限</p>
<p>权限管理</p>
<ul>
<li><p>哪些页面要设置权限</p>
</li>
<li><p>哪些操作要设置权限</p>
</li>
<li><p>哪些数据要设置权限</p>
</li>
</ul>
<p>权限管理最终是为了风控，即哪个部门哪个用户具有哪个权限。</p>
<p><strong>RBAC(Role-Based Access Control)</strong></p>
<p>​        用户                   =》             角色             =》            权限</p>
<ul>
<li><p>账号                                      集合                                页面权限</p>
</li>
<li><p>钥匙                                      桥梁                                操作权限</p>
</li>
<li><p>​                                                                                     数据权限</p>
</li>
</ul>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20210102212008008.png" alt="image-20210102212008008"></p>
<p>​    </p>
<h1 id="SpringSecurity单体架构实现"><a href="#SpringSecurity单体架构实现" class="headerlink" title="SpringSecurity单体架构实现"></a>SpringSecurity单体架构实现</h1><ul>
<li><h3 id="HttpBasic模式的认证"><a href="#HttpBasic模式的认证" class="headerlink" title="HttpBasic模式的认证"></a>HttpBasic模式的认证</h3></li>
<li><h3 id="FormLogin模式的认证"><a href="#FormLogin模式的认证" class="headerlink" title="FormLogin模式的认证"></a>FormLogin模式的认证</h3></li>
<li><h3 id="前后端分离架构的认证"><a href="#前后端分离架构的认证" class="headerlink" title="前后端分离架构的认证"></a>前后端分离架构的认证</h3></li>
<li><h3 id="基于Docker-的一键部署"><a href="#基于Docker-的一键部署" class="headerlink" title="基于Docker 的一键部署"></a>基于Docker 的一键部署</h3></li>
</ul>
<h3 id="FormLogin模式的认证-1"><a href="#FormLogin模式的认证-1" class="headerlink" title="FormLogin模式的认证"></a>FormLogin模式的认证</h3><ol>
<li>编写login.html</li>
<li>创建一个继承WebSecurityConfigurerAdapterSecurityConfig的类</li>
<li>重写configure(HttpSecurity http)配置登录验证逻辑</li>
<li>重写configure(AuthenticationManagerBuilder auth)实现内存中身份认证</li>
<li>运行认证</li>
</ol>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20210114210652663.png" alt="image-20210114210652663"></p>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20210117225117523.png" alt="image-20210117225117523"></p>
<h1 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h1><p>Json Web Token(JWT)</p>
<p><strong>Head</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;,</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>payload</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;sub&quot;: &quot;1234567890&quot;,  </span><br><span class="line">  &quot;name&quot;: &quot;John Doe&quot;,</span><br><span class="line">  &quot;iat&quot;: 1516239022</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss: jwt签发这</span><br><span class="line">sub: jwt所面向的用户</span><br><span class="line">aud: 接收jwt的一方</span><br><span class="line">exp: jwt的过期时间，这个过期时间必须要大于签发时间</span><br><span class="line">nbf: 定义在什么时间之前，该jwt都是不可用的</span><br><span class="line">iat: jwt的签发时间</span><br><span class="line">jti: jwt的唯一身份标识，主要用来作为一次性token，从而回避重放攻击</span><br></pre></td></tr></table></figure>

<p>签名 signature</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + &quot;.&quot; +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  </span><br><span class="line">your-256-bit-secret</span><br><span class="line"></span><br><span class="line">) secret base64 encoded</span><br></pre></td></tr></table></figure>

<p>签证信息由三部分组成</p>
<ol>
<li>header（base64后的）</li>
<li>payload（base64后的）</li>
<li>secret（盐，一定要保密）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/SpringCloud%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/SpringCloud%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2021-03-10 19:51:59" itemprop="dateModified" datetime="2021-03-10T19:51:59+08:00">2021-03-10</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="狂神说spring-cloud学习笔记"><a href="#狂神说spring-cloud学习笔记" class="headerlink" title="狂神说spring cloud学习笔记"></a>狂神说spring cloud学习笔记</h2><h3 id="1-学习前言"><a href="#1-学习前言" class="headerlink" title="1. 学习前言"></a>1. 学习前言</h3><h4 id="1-1-内容概述"><a href="#1-1-内容概述" class="headerlink" title="1.1 内容概述"></a>1.1 内容概述</h4><blockquote>
<p>学习前提：</p>
</blockquote>
<ul>
<li>熟练使用SpringBoot 微服务快速开发框架</li>
<li>了解过Dubbo + Zookeeper 分布式基础</li>
<li>电脑配置内存不低于8G(我自己的是16G)</li>
</ul>
<blockquote>
<p>Spring Cloud 五大组件</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">服务注册与发现——Netflix Eureka</span><br><span class="line"></span><br><span class="line">负载均衡：</span><br><span class="line"></span><br><span class="line">客户端负载均衡——Netflix Ribbon</span><br><span class="line">服务端负载均衡：——Feign(其也是依赖于Ribbon，只是将调用方式RestTemplete 更改成Service 接口)</span><br><span class="line">断路器——Netflix Hystrix</span><br><span class="line"></span><br><span class="line">服务网关——Netflix Zuul</span><br><span class="line"></span><br><span class="line">分布式配置——Spring Cloud Config</span><br></pre></td></tr></table></figure>

<h4 id="1-2-常见面试题"><a href="#1-2-常见面试题" class="headerlink" title="1.2 常见面试题"></a>1.2 常见面试题</h4><p>1.1 什么是微服务？</p>
<p>1.2 微服务之间是如何独立通讯的？</p>
<p>1.3 SpringCloud 和 Dubbo有那些区别？</p>
<p>1.4 SpringBoot 和 SpringCloud，请谈谈你对他们的理解</p>
<p>1.5 什么是服务熔断？什么是服务降级？</p>
<p>1.6 微服务的优缺点分别是什么？说下你在项目开发中遇到的坑</p>
<p>1.7 你所知道的微服务技术栈有哪些？列举一二</p>
<p>1.8 Eureka和Zookeeper都可以提供服务注册与发现的功能，请说说两者的区别</p>
<p>…</p>
<h3 id="2-微服务概述"><a href="#2-微服务概述" class="headerlink" title="2. 微服务概述"></a>2. 微服务概述</h3><h4 id="2-1-什么是微服务？"><a href="#2-1-什么是微服务？" class="headerlink" title="2.1 什么是微服务？"></a>2.1 什么是微服务？</h4><p><strong>什么是微服务？</strong>微服务(Microservice Architecture) 是近几年流行的一种架构思想，关于它的概念很难一言以蔽之。</p>
<p>究竟什么是微服务呢？我们在此引用ThoughtWorks 公司的首席科学家 Martin Fowler 于2014年提出的一段话：</p>
<ul>
<li>就目前而言，对于微服务，业界并没有一个统一的，标准的定义。</li>
<li>但通常而言，微服务架构是一种架构模式，或者说是一种架构风格，<strong>它体长将单一的应用程序划分成一组小的服务</strong>，每个服务运行在其独立的自己的进程内，服务之间互相协调，互相配置，为用户提供最终价值，服务之间采用轻量级的通信机制(<strong>HTTP</strong>)互相沟通，每个服务都围绕着具体的业务进行构建，并且能狗被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应该根据业务上下文，选择合适的语言，工具(<strong>Maven</strong>)对其进行构建，可以有一个非常轻量级的集中式管理来协调这些服务，可以使用不同的语言来编写服务，也可以使用不同的数据存储。</li>
</ul>
<p><strong>再来从技术维度角度理解下：</strong></p>
<ul>
<li>微服务化的核心就是将传统的一站式应用，根据业务拆分成一个一个的服务，彻底地去耦合，每一个微服务提供单个业务功能的服务，一个服务做一件事情，从技术角度看就是一种小而独立的处理过程，类似进程的概念，能够自行单独启动或销毁，拥有自己独立的数据库。</li>
</ul>
<h4 id="2-2-微服务与微服务架构"><a href="#2-2-微服务与微服务架构" class="headerlink" title="2.2 微服务与微服务架构"></a>2.2 微服务与微服务架构</h4><p><strong>微服务</strong></p>
<p>强调的是服务的大小，它关注的是某一个点，是具体解决某一个问题/提供落地对应服务的一个服务应用，狭义的看，可以看作是IDEA中的一个个微服务工程，或者Moudel。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDEA 工具里面使用Maven开发的一个个独立的小Moudel，它具体是使用SpringBoot开发的一个小模块，专业的事情交给专业的模块来做，一个模块就做着一件事情。强调的是一个个的个体，每个个体完成一个具体的任务或者功能。</span><br></pre></td></tr></table></figure>

<p><strong>微服务架构</strong></p>
<p>一种新的架构形式，Martin Fowler 于2014年提出。</p>
<p>微服务架构是一种架构模式，它体长将单一应用程序划分成一组小的服务，服务之间相互协调，互相配合，为用户提供最终价值。每个服务运行在其独立的进程中，服务与服务之间采用轻量级的通信机制**(如HTTP)<strong>互相协作，每个服务都围绕着具体的业务进行构建，并且能够被独立的部署到生产环境中，另外，应尽量避免统一的，集中式的服务管理机制，对具体的一个服务而言，应根据业务上下文，选择合适的语言、工具</strong>(如Maven)**对其进行构建。</p>
<h4 id="2-3-微服务优缺点"><a href="#2-3-微服务优缺点" class="headerlink" title="2.3 微服务优缺点"></a>2.3 微服务优缺点</h4><p><strong>优点</strong></p>
<ul>
<li>单一职责原则；</li>
<li>每个服务足够内聚，足够小，代码容易理解，这样能聚焦一个指定的业务功能或业务需求；</li>
<li>开发简单，开发效率高，一个服务可能就是专一的只干一件事；</li>
<li>微服务能够被小团队单独开发，这个团队只需2-5个开发人员组成；</li>
<li>微服务是松耦合的，是有功能意义的服务，无论是在开发阶段或部署阶段都是独立的；</li>
<li>微服务能使用不同的语言开发；</li>
<li>易于和第三方集成，微服务允许容易且灵活的方式集成自动部署，通过持续集成工具，如jenkins，Hudson，bamboo；</li>
<li>微服务易于被一个开发人员理解，修改和维护，这样小团队能够更关注自己的工作成果，无需通过合作才能体现价值；</li>
<li>微服务允许利用和融合最新技术；</li>
<li><strong>微服务只是业务逻辑的代码，不会和HTML，CSS，或其他的界面混合;</strong></li>
<li><strong>每个微服务都有自己的存储能力，可以有自己的数据库，也可以有统一的数据库；</strong></li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>开发人员要处理分布式系统的复杂性；</li>
<li>多服务运维难度，随着服务的增加，运维的压力也在增大；</li>
<li>系统部署依赖问题；</li>
<li>服务间通信成本问题；</li>
<li>数据一致性问题；</li>
<li>系统集成测试问题；</li>
<li>性能和监控问题；</li>
</ul>
<h4 id="2-4-微服务技术栈有那些？"><a href="#2-4-微服务技术栈有那些？" class="headerlink" title="2.4 微服务技术栈有那些？"></a>2.4 微服务技术栈有那些？</h4><table>
<thead>
<tr>
<th align="left"><strong>微服务技术条目</strong></th>
<th align="left">落地技术</th>
</tr>
</thead>
<tbody><tr>
<td align="left">服务开发</td>
<td align="left">SpringBoot、Spring、SpringMVC等</td>
</tr>
<tr>
<td align="left">服务配置与管理</td>
<td align="left">Netfix公司的Archaius、阿里的Diamond等</td>
</tr>
<tr>
<td align="left">服务注册与发现</td>
<td align="left">Eureka、Consul、Zookeeper等</td>
</tr>
<tr>
<td align="left">服务调用</td>
<td align="left">Rest、PRC、gRPC</td>
</tr>
<tr>
<td align="left">服务熔断器</td>
<td align="left">Hystrix、Envoy等</td>
</tr>
<tr>
<td align="left">负载均衡</td>
<td align="left">Ribbon、Nginx等</td>
</tr>
<tr>
<td align="left">服务接口调用(客户端调用服务的简化工具)</td>
<td align="left">Fegin等</td>
</tr>
<tr>
<td align="left">消息队列</td>
<td align="left">Kafka、RabbitMQ、ActiveMQ等</td>
</tr>
<tr>
<td align="left">服务配置中心管理</td>
<td align="left">SpringCloudConfig、Chef等</td>
</tr>
<tr>
<td align="left">服务路由(API网关)</td>
<td align="left">Zuul等</td>
</tr>
<tr>
<td align="left">服务监控</td>
<td align="left">Zabbix、Nagios、Metrics、Specatator等</td>
</tr>
<tr>
<td align="left">全链路追踪</td>
<td align="left">Zipkin、Brave、Dapper等</td>
</tr>
<tr>
<td align="left">数据流操作开发包</td>
<td align="left">SpringCloud Stream(封装与Redis，Rabbit，Kafka等发送接收消息)</td>
</tr>
<tr>
<td align="left">时间消息总栈</td>
<td align="left">SpringCloud Bus</td>
</tr>
<tr>
<td align="left">服务部署</td>
<td align="left">Docker、OpenStack、Kubernetes等</td>
</tr>
</tbody></table>
<h4 id="2-5-为什么选择SpringCloud作为微服务架构"><a href="#2-5-为什么选择SpringCloud作为微服务架构" class="headerlink" title="2.5 为什么选择SpringCloud作为微服务架构"></a>2.5 为什么选择SpringCloud作为微服务架构</h4><ol>
<li><p>选型依据</p>
<ul>
<li>整体解决方案和框架成熟度</li>
<li>社区热度</li>
<li>可维护性</li>
<li>学习曲线</li>
</ul>
</li>
<li><p>当前各大IT公司用的微服务架构有那些？</p>
<ul>
<li><p>阿里：dubbo+HFS</p>
</li>
<li><p>京东：JFS</p>
</li>
<li><p>新浪：Motan</p>
</li>
<li><p>当当网：DubboX</p>
<p>…</p>
</li>
</ul>
</li>
<li><p>各微服务框架对比</p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="left"><strong>功能点/服务框架</strong></th>
<th align="left">Netflix/SpringCloud</th>
<th align="left">Motan</th>
<th align="left">gRPC</th>
<th align="left">Thrift</th>
<th align="left">Dubbo/DubboX</th>
</tr>
</thead>
<tbody><tr>
<td align="left">功能定位</td>
<td align="left">完整的微服务框架</td>
<td align="left">RPC框架，但整合了ZK或Consul，实现集群环境的基本服务注册发现</td>
<td align="left">RPC框架</td>
<td align="left">RPC框架</td>
<td align="left">服务框架</td>
</tr>
<tr>
<td align="left">支持Rest</td>
<td align="left">是，Ribbon支持多种可拔插的序列号选择</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">支持RPC</td>
<td align="left">否</td>
<td align="left">是(Hession2)</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">是</td>
</tr>
<tr>
<td align="left">支持多语言</td>
<td align="left">是(Rest形式)</td>
<td align="left">否</td>
<td align="left">是</td>
<td align="left">是</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">负载均衡</td>
<td align="left">是(服务端zuul+客户端Ribbon)，zuul-服务，动态路由，云端负载均衡Eureka（针对中间层服务器）</td>
<td align="left">是(客户端)</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是(客户端)</td>
</tr>
<tr>
<td align="left">配置服务</td>
<td align="left">Netfix Archaius，Spring Cloud Config Server 集中配置</td>
<td align="left">是(Zookeeper提供)</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">服务调用链监控</td>
<td align="left">是(zuul)，zuul提供边缘服务，API网关</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">否</td>
</tr>
<tr>
<td align="left">高可用/容错</td>
<td align="left">是(服务端Hystrix+客户端Ribbon)</td>
<td align="left">是(客户端)</td>
<td align="left">否</td>
<td align="left">否</td>
<td align="left">是(客户端)</td>
</tr>
<tr>
<td align="left">典型应用案例</td>
<td align="left">Netflix</td>
<td align="left">Sina</td>
<td align="left">Google</td>
<td align="left">Facebook</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">社区活跃程度</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">2017年后重新开始维护，之前中断了5年</td>
</tr>
<tr>
<td align="left">学习难度</td>
<td align="left">中等</td>
<td align="left">低</td>
<td align="left">高</td>
<td align="left">高</td>
<td align="left">低</td>
</tr>
<tr>
<td align="left">文档丰富程度</td>
<td align="left">高</td>
<td align="left">一般</td>
<td align="left">一般</td>
<td align="left">一般</td>
<td align="left">高</td>
</tr>
<tr>
<td align="left">其他</td>
<td align="left">Spring Cloud Bus为我们的应用程序带来了更多管理端点</td>
<td align="left">支持降级</td>
<td align="left">Netflix内部在开发集成gRPC</td>
<td align="left">IDL定义</td>
<td align="left">实践的公司比较多</td>
</tr>
</tbody></table>
<h3 id="3-SpringCloud入门概述"><a href="#3-SpringCloud入门概述" class="headerlink" title="3. SpringCloud入门概述"></a>3. SpringCloud入门概述</h3><h4 id="3-1-SpringCloud是什么？"><a href="#3-1-SpringCloud是什么？" class="headerlink" title="3.1 SpringCloud是什么？"></a>3.1 SpringCloud是什么？</h4><p>Spring官网：<a target="_blank" rel="noopener" href="https://spring.io/">https://spring.io/</a></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczEuYmRzdGF0aWMuY29tLzcwY0Z1WFNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTM1NzgwMTc3ODAsMTIxODQyMDAyOSZmbT0yNiZncD0wLmpwZw?x-oss-process=image/format,png" alt="img"></p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTE2Mzc3ODY4OTcsNzQ1MTM1MjUxJmZtPTI2JmdwPTAuanBn?x-oss-process=image/format,png" alt="img"></p>
<p>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.</p>
<p>翻译：</p>
<p>Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具(例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导人选举、分布式会话、集群状态)。分布式系统的协调导致了锅炉板模式，而使用Spring Cloud开发人员可以快速建立实现这些模式的服务和应用程序。它们在任何分布式环境中都能很好地工作，包括开发人员自己的笔记本电脑、裸金属数据中心和云计算等托管平台。</p>
<h4 id="3-2-SpringCloud和SpringBoot的关系"><a href="#3-2-SpringCloud和SpringBoot的关系" class="headerlink" title="3.2 SpringCloud和SpringBoot的关系"></a>3.2 SpringCloud和SpringBoot的关系</h4><ul>
<li>SpringBoot专注于开苏方便的开发单个个体微服务；</li>
<li>SpringCloud是关注全局的微服务协调整理治理框架，它将SpringBoot开发的一个个单体微服务，整合并管理起来，为各个微服务之间提供：配置管理、服务发现、断路器、路由、为代理、事件总栈、全局锁、决策竞选、分布式会话等等集成服务；</li>
<li>SpringBoot可以离开SpringCloud独立使用，开发项目，但SpringCloud离不开SpringBoot，属于依赖关系；</li>
<li>**SpringBoot专注于快速、方便的开发单个个体微服务，SpringCloud关注全局的服务治理框架；</li>
</ul>
<h4 id="3-3-Dubbo-和-SpringCloud技术选型"><a href="#3-3-Dubbo-和-SpringCloud技术选型" class="headerlink" title="3.3 Dubbo 和 SpringCloud技术选型"></a>3.3 Dubbo 和 SpringCloud技术选型</h4><h5 id="1-分布式-服务治理Dubbo"><a href="#1-分布式-服务治理Dubbo" class="headerlink" title="1. 分布式+服务治理Dubbo"></a>1. 分布式+服务治理Dubbo</h5><p>目前成熟的互联网架构，应用服务化拆分+消息中间件</p>
<h5 id="2-Dubbo-和-SpringCloud对比"><a href="#2-Dubbo-和-SpringCloud对比" class="headerlink" title="2. Dubbo 和 SpringCloud对比"></a>2. Dubbo 和 SpringCloud对比</h5><p>可以看一下社区活跃度：</p>
<p><a target="_blank" rel="noopener" href="https://github.com/dubbo">https://github.com/dubbo</a></p>
<p><a target="_blank" rel="noopener" href="https://github.com/spring-cloud">https://github.com/spring-cloud</a></p>
<p><strong>对比结果：</strong></p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">Dubbo</th>
<th align="left">SpringCloud</th>
</tr>
</thead>
<tbody><tr>
<td align="left">服务注册中心</td>
<td align="left">Zookeeper</td>
<td align="left">Spring Cloud Netfilx Eureka</td>
</tr>
<tr>
<td align="left">服务调用方式</td>
<td align="left">RPC</td>
<td align="left">REST API</td>
</tr>
<tr>
<td align="left">服务监控</td>
<td align="left">Dubbo-monitor</td>
<td align="left">Spring Boot Admin</td>
</tr>
<tr>
<td align="left">断路器</td>
<td align="left">不完善</td>
<td align="left">Spring Cloud Netfilx Hystrix</td>
</tr>
<tr>
<td align="left">服务网关</td>
<td align="left">无</td>
<td align="left">Spring Cloud Netfilx Zuul</td>
</tr>
<tr>
<td align="left">分布式配置</td>
<td align="left">无</td>
<td align="left">Spring Cloud Config</td>
</tr>
<tr>
<td align="left">服务跟踪</td>
<td align="left">无</td>
<td align="left">Spring Cloud Sleuth</td>
</tr>
<tr>
<td align="left">消息总栈</td>
<td align="left">无</td>
<td align="left">Spring Cloud Bus</td>
</tr>
<tr>
<td align="left">数据流</td>
<td align="left">无</td>
<td align="left">Spring Cloud Stream</td>
</tr>
<tr>
<td align="left">批量任务</td>
<td align="left">无</td>
<td align="left">Spring Cloud Task</td>
</tr>
</tbody></table>
<p><strong>最大区别：Spring Cloud 抛弃了Dubbo的RPC通信，采用的是基于HTTP的REST方式</strong></p>
<p>严格来说，这两种方式各有优劣。虽然从一定程度上来说，后者牺牲了服务调用的性能，但也避免了上面提到的原生RPC带来的问题。而且REST相比RPC更为灵活，服务提供方和调用方的依赖只依靠一纸契约，不存在代码级别的强依赖，这个优点在当下强调快速演化的微服务环境下，显得更加合适。</p>
<p><strong>品牌机和组装机的区别</strong></p>
<p><strong>社区支持与更新力度的区别</strong></p>
<p><strong>总结：</strong></p>
<p> <strong>二者解决的问题域不一样：Dubbo的定位是一款RPC框架，而SpringCloud的目标是微服务架构下的一站式解决方案。</strong></p>
<h4 id="3-4-SpringCloud能干嘛？"><a href="#3-4-SpringCloud能干嘛？" class="headerlink" title="3.4 SpringCloud能干嘛？"></a>3.4 SpringCloud能干嘛？</h4><ul>
<li>Distributed/versioned configuration 分布式/版本控制配置</li>
<li>Service registration and discovery 服务注册与发现</li>
<li>Routing 路由</li>
<li>Service-to-service calls 服务到服务的调用</li>
<li>Load balancing 负载均衡配置</li>
<li>Circuit Breakers 断路器</li>
<li>Distributed messaging 分布式消息管理</li>
<li>…</li>
</ul>
<h4 id="3-5-SpringCloud下载"><a href="#3-5-SpringCloud下载" class="headerlink" title="3.5 SpringCloud下载"></a>3.5 SpringCloud下载</h4><p>官网：<a target="_blank" rel="noopener" href="http://projects.spring.io/spring-cloud/">http://projects.spring.io/spring-cloud/</a></p>
<p>版本号有点特别：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521130004420.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>SpringCloud没有采用数字编号的方式命名版本号，而是采用了伦敦地铁站的名称，<strong>同时根据字母表的顺序来对应版本时间顺序</strong>，比如最早的Realse版本：Angel，第二个Realse版本：Brixton，然后是Camden、Dalston、Edgware，目前最新的是Hoxton SR4 CURRENT GA通用稳定版。</p>
<p><strong>自学参考书：</strong></p>
<ul>
<li>SpringCloud Netflix 中文文档：<a target="_blank" rel="noopener" href="https://springcloud.cc/spring-cloud-netflix.html">https://springcloud.cc/spring-cloud-netflix.html</a></li>
<li>SpringCloud 中文API文档(官方文档翻译版)：<a target="_blank" rel="noopener" href="https://springcloud.cc/spring-cloud-dalston.html">https://springcloud.cc/spring-cloud-dalston.html</a></li>
<li>SpringCloud中国社区：<a target="_blank" rel="noopener" href="http://springcloud.cn/">http://springcloud.cn/</a></li>
<li>SpringCloud中文网：<a target="_blank" rel="noopener" href="https://springcloud.cc/">https://springcloud.cc</a></li>
</ul>
<h3 id="4-SpringCloud-Rest学习环境搭建：服务提供者"><a href="#4-SpringCloud-Rest学习环境搭建：服务提供者" class="headerlink" title="4. SpringCloud Rest学习环境搭建：服务提供者"></a>4. SpringCloud Rest学习环境搭建：服务提供者</h3><h4 id="4-1-介绍"><a href="#4-1-介绍" class="headerlink" title="4.1 介绍"></a>4.1 介绍</h4><ul>
<li>我们会使用一个Dept部门模块做一个微服务通用案例Consumer消费者(Client)通过REST调用Provider提供者(Server)提供的服务。</li>
<li>回顾Spring，SpringMVC，Mybatis等以往学习的知识。</li>
<li>Maven的分包分模块架构复习。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个简单的Maven模块结构是这样的：-- app-parent: 一个父项目(app-parent)聚合了很多子项目(app-util\app-dao\app-web...)  |-- pom.xml  |  |-- app-core  ||---- pom.xml  |  |-- app-web  ||---- pom.xml  ......</span><br></pre></td></tr></table></figure>

<p>一个父工程带着多个Moudule子模块</p>
<p>MicroServiceCloud父工程(Project)下初次带着3个子模块(Module)</p>
<ul>
<li>microservicecloud-api 【封装的整体entity/接口/公共配置等】</li>
<li>microservicecloud-consumer-dept-80 【服务提供者】</li>
<li>microservicecloud-provider-dept-8001 【服务消费者】</li>
</ul>
<h4 id="4-2-SpringCloud版本选择"><a href="#4-2-SpringCloud版本选择" class="headerlink" title="4.2 SpringCloud版本选择"></a>4.2 SpringCloud版本选择</h4><p><strong>大版本说明</strong></p>
<table>
<thead>
<tr>
<th align="left">SpringBoot</th>
<th align="left">SpringCloud</th>
<th align="left">关系</th>
</tr>
</thead>
<tbody><tr>
<td align="left">1.2.x</td>
<td align="left">Angel版本(天使)</td>
<td align="left">兼容SpringBoot1.2x</td>
</tr>
<tr>
<td align="left">1.3.x</td>
<td align="left">Brixton版本(布里克斯顿)</td>
<td align="left">兼容SpringBoot1.3x，也兼容SpringBoot1.4x</td>
</tr>
<tr>
<td align="left">1.4.x</td>
<td align="left">Camden版本(卡姆登)</td>
<td align="left">兼容SpringBoot1.4x，也兼容SpringBoot1.5x</td>
</tr>
<tr>
<td align="left">1.5.x</td>
<td align="left">Dalston版本(多尔斯顿)</td>
<td align="left">兼容SpringBoot1.5x，不兼容SpringBoot2.0x</td>
</tr>
<tr>
<td align="left">1.5.x</td>
<td align="left">Edgware版本(埃奇韦尔)</td>
<td align="left">兼容SpringBoot1.5x，不兼容SpringBoot2.0x</td>
</tr>
<tr>
<td align="left">2.0.x</td>
<td align="left">Finchley版本(芬奇利)</td>
<td align="left">兼容SpringBoot2.0x，不兼容SpringBoot1.5x</td>
</tr>
<tr>
<td align="left">2.1.x</td>
<td align="left">Greenwich版本(格林威治)</td>
<td align="left"></td>
</tr>
</tbody></table>
<p><strong>实际开发版本关系</strong></p>
<table>
<thead>
<tr>
<th align="center">spring-boot-starter-parent</th>
<th align="right"></th>
<th align="center">spring-cloud-dependencles</th>
<th align="center"></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>版本号</strong></td>
<td align="right"><strong>发布日期</strong></td>
<td align="center"><strong>版本号</strong></td>
<td align="center"><strong>发布日期</strong></td>
</tr>
<tr>
<td align="center">1.5.2.RELEASE</td>
<td align="right">2017-03</td>
<td align="center">Dalston.RC1</td>
<td align="center">2017-x</td>
</tr>
<tr>
<td align="center">1.5.9.RELEASE</td>
<td align="right">2017-11</td>
<td align="center">Edgware.RELEASE</td>
<td align="center">2017-11</td>
</tr>
<tr>
<td align="center">1.5.16.RELEASE</td>
<td align="right">2018-04</td>
<td align="center">Edgware.SR5</td>
<td align="center">2018-10</td>
</tr>
<tr>
<td align="center">1.5.20.RELEASE</td>
<td align="right">2018-09</td>
<td align="center">Edgware.SR5</td>
<td align="center">2018-10</td>
</tr>
<tr>
<td align="center">2.0.2.RELEASE</td>
<td align="right">2018-05</td>
<td align="center">Fomchiey.BULD-SNAPSHOT</td>
<td align="center">2018-x</td>
</tr>
<tr>
<td align="center">2.0.6.RELEASE</td>
<td align="right">2018-10</td>
<td align="center">Fomchiey-SR2</td>
<td align="center">2018-10</td>
</tr>
<tr>
<td align="center">2.1.4.RELEASE</td>
<td align="right">2019-04</td>
<td align="center">Greenwich.SR1</td>
<td align="center">2019-03</td>
</tr>
</tbody></table>
<p><strong>使用后两个</strong></p>
<h4 id="4-3-创建父工程"><a href="#4-3-创建父工程" class="headerlink" title="4.3 创建父工程"></a>4.3 创建父工程</h4><ul>
<li>新建父工程项目springcloud，切记<strong>Packageing是pom模式</strong></li>
<li>主要是定义POM文件，将后续各个子模块公用的jar包等统一提取出来，类似一个抽象父类<br><img src="https://img-blog.csdnimg.cn/20200521130052880.png#pic_center" alt="在这里插入图片描述"></li>
</ul>
<p><strong>pom.xml</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot;         xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;         xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;    &lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;    &lt;groupId&gt;com.haust&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springcloud&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;    &lt;modules&gt;        &lt;module&gt;springcloud-api&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-provider-dept-8001&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-consumer-dept-80&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-eureka-7001&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-eureka-7002&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-eureka-7003&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-provider-dept-8002&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-provider-dept-8003&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-consumer-dept-feign&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-provider-dept-hystrix-8001&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-consumer-hystrix-dashboard&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-zuul-9527&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-config-server-3344&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-config-client-3355&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-config-eureka-7001&lt;&#x2F;module&gt;        &lt;module&gt;springcloud-config-dept-8001&lt;&#x2F;module&gt;    &lt;&#x2F;modules&gt;    &lt;!--打包方式  pom--&gt;    &lt;packaging&gt;pom&lt;&#x2F;packaging&gt;    &lt;properties&gt;        &lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;        &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;        &lt;junit.version&gt;4.12&lt;&#x2F;junit.version&gt;        &lt;log4j.version&gt;1.2.17&lt;&#x2F;log4j.version&gt;        &lt;lombok.version&gt;1.16.18&lt;&#x2F;lombok.version&gt;    &lt;&#x2F;properties&gt;    &lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-cloud-alibaba-dependencies&lt;&#x2F;artifactId&gt;                &lt;version&gt;0.2.0.RELEASE&lt;&#x2F;version&gt;                &lt;type&gt;pom&lt;&#x2F;type&gt;                &lt;scope&gt;import&lt;&#x2F;scope&gt;            &lt;&#x2F;dependency&gt;            &lt;!--springCloud的依赖--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-cloud-dependencies&lt;&#x2F;artifactId&gt;                &lt;version&gt;Greenwich.SR1&lt;&#x2F;version&gt;                &lt;type&gt;pom&lt;&#x2F;type&gt;                &lt;scope&gt;import&lt;&#x2F;scope&gt;            &lt;&#x2F;dependency&gt;            &lt;!--SpringBoot--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;                &lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;                &lt;type&gt;pom&lt;&#x2F;type&gt;                &lt;scope&gt;import&lt;&#x2F;scope&gt;            &lt;&#x2F;dependency&gt;            &lt;!--数据库--&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;                &lt;version&gt;5.1.47&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;druid&lt;&#x2F;artifactId&gt;                &lt;version&gt;1.1.10&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;            &lt;!--SpringBoot 启动器--&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;                &lt;version&gt;1.3.2&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;            &lt;!--日志测试~--&gt;            &lt;dependency&gt;                &lt;groupId&gt;ch.qos.logback&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;logback-core&lt;&#x2F;artifactId&gt;                &lt;version&gt;1.2.3&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;log4j&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;log4j&lt;&#x2F;artifactId&gt;                &lt;version&gt;$&#123;log4j.version&#125;&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;                &lt;version&gt;$&#123;lombok.version&#125;&lt;&#x2F;version&gt;            &lt;&#x2F;dependency&gt;        &lt;&#x2F;dependencies&gt;    &lt;&#x2F;dependencyManagement&gt;&lt;&#x2F;project&gt;</span><br></pre></td></tr></table></figure>

<p>父工程为springcloud，其下有多个子mudule，详情参考完整代码了解</p>
<p><img src="https://img-blog.csdnimg.cn/20200521130118985.png#pic_center" alt="在这里插入图片描述"></p>
<p>springcloud-consumer-dept-80访问springcloud-provider-dept-8001下的controller使用REST方式</p>
<p>如DeptConsumerController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerpublic class DeptConsumerController &#123;    &#x2F;&#x2F; 理解：消费者，不应该有service层~    &#x2F;&#x2F; RestTemplate .... 供我们直接调用就可以了！ 注册到Spring中    &#x2F;&#x2F; (url, 实体：Map ,Class&lt;T&gt; responseType)    @Autowired    private RestTemplate restTemplate; &#x2F;&#x2F;提供多种便捷访问远程http服务的方法，简单的Restful服务模板~    &#x2F;&#x2F;Ribbon。我们这里的地址，应该是一个变量，通过服务名来访问    private static final String REST_URL_PREFIX &#x3D; &quot;http:&#x2F;&#x2F;localhost:8001&quot;;    &#x2F;&#x2F;private static final String REST_URL_PREFIX &#x3D; &quot;http:&#x2F;&#x2F;SPRINGCLOUD-PROVIDER-DEPT&quot;;    @RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;add&quot;)    public boolean add(Dept dept)&#123;        return restTemplate.postForObject(REST_URL_PREFIX+&quot;&#x2F;dept&#x2F;add&quot;,dept,Boolean.class);    &#125;    @RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;get&#x2F;&#123;id&#125;&quot;)    public Dept get(@PathVariable(&quot;id&quot;) Long id)&#123;        return restTemplate.getForObject(REST_URL_PREFIX+&quot;&#x2F;dept&#x2F;get&#x2F;&quot;+id,Dept.class);    &#125;    @RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;list&quot;)    public List&lt;Dept&gt; list()&#123;        return restTemplate.getForObject(REST_URL_PREFIX+&quot;&#x2F;dept&#x2F;list&quot;,List.class);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>使用RestTemplete先需要放入Spring容器中</p>
<p>ConfigBean.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Configurationpublic class ConfigBean &#123;&#x2F;&#x2F;@Configuration -- spring  applicationContext.xml    &#x2F;&#x2F;配置负载均衡实现RestTemplate    &#x2F;&#x2F; IRule    &#x2F;&#x2F; RoundRobinRule 轮询    &#x2F;&#x2F; RandomRule 随机    &#x2F;&#x2F; AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~    &#x2F;&#x2F; RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试    @Bean    public RestTemplate getRestTemplate()&#123;        return new RestTemplate();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>springcloud-provider-dept-8001的dao接口调用springcloud-api模块下的pojo，可使用在springcloud-provider-dept-8001的pom文件导入springcloud-api模块依赖的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--我们需要拿到实体类，所以要配置api module--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.haust&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;springcloud-api&lt;&#x2F;artifactId&gt;            &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;        &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>springcloud-consumer-dept-80和springcloud-provider-dept-8001的pom.xml和父工程下的依赖基本一样，直接看完整代码即可，不再添加重复笔记。</p>
<h3 id="5-Eureka服务注册与发现"><a href="#5-Eureka服务注册与发现" class="headerlink" title="5. Eureka服务注册与发现"></a>5. Eureka服务注册与发现</h3><h4 id="5-1-什么是Eureka"><a href="#5-1-什么是Eureka" class="headerlink" title="5.1 什么是Eureka"></a>5.1 什么是Eureka</h4><ul>
<li>Netflix在涉及Eureka时，遵循的就是API原则.</li>
<li>Eureka是Netflix的有个子模块，也是核心模块之一。Eureka是基于REST的服务，用于定位服务，以实现云端中间件层服务发现和故障转移，服务注册与发现对于微服务来说是非常重要的，有了服务注册与发现，只需要使用服务的标识符，就可以访问到服务，而不需要修改服务调用的配置文件了，功能类似于Dubbo的注册中心，比如Zookeeper.</li>
</ul>
<h4 id="5-2-原理理解"><a href="#5-2-原理理解" class="headerlink" title="5.2 原理理解"></a>5.2 原理理解</h4><ul>
<li><strong>Eureka基本的架构</strong><ul>
<li>Springcloud 封装了Netflix公司开发的Eureka模块来实现服务注册与发现 (对比Zookeeper).</li>
<li>Eureka采用了C-S的架构设计，EurekaServer作为服务注册功能的服务器，他是服务注册中心.</li>
<li>而系统中的其他微服务，使用Eureka的客户端连接到EurekaServer并维持心跳连接。这样系统的维护人员就可以通过EurekaServer来监控系统中各个微服务是否正常运行，Springcloud 的一些其他模块 (比如Zuul) 就可以通过EurekaServer来发现系统中的其他微服务，并执行相关的逻辑.</li>
</ul>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200521130157770.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li>和Dubbo架构对比.</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200521130222344.png#pic_center" alt="在这里插入图片描述"></p>
<ul>
<li><p>Eureka 包含两个组件：<strong>Eureka Server</strong> 和 <strong>Eureka Client</strong>.</p>
</li>
<li><p>Eureka Server 提供服务注册，各个节点启动后，回在EurekaServer中进行注册，这样Eureka Server中的服务注册表中将会储存所有课用服务节点的信息，服务节点的信息可以在界面中直观的看到.</p>
</li>
<li><p>Eureka Client 是一个Java客户端，用于简化EurekaServer的交互，客户端同时也具备一个内置的，使用轮询负载算法的负载均衡器。在应用启动后，将会向EurekaServer发送心跳 (默认周期为30秒) 。如果Eureka Server在多个心跳周期内没有接收到某个节点的心跳，EurekaServer将会从服务注册表中把这个服务节点移除掉 (默认周期为90s).</p>
</li>
<li><p><strong>三大角色</strong></p>
<ul>
<li>Eureka Server：提供服务的注册与发现</li>
<li>Service Provider：服务生产方，将自身服务注册到Eureka中，从而使服务消费方能狗找到</li>
<li>Service Consumer：服务消费方，从Eureka中获取注册服务列表，从而找到消费服务</li>
</ul>
</li>
<li><p>目前工程状况</p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20200521130244579.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="5-3-构建步骤"><a href="#5-3-构建步骤" class="headerlink" title="5.3 构建步骤"></a>5.3 构建步骤</h4><h5 id="1-eureka-server"><a href="#1-eureka-server" class="headerlink" title="1. eureka-server"></a>1. eureka-server</h5><ol>
<li><p>springcloud-eureka-7001 模块建立</p>
</li>
<li><p>pom.xml 配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导包~--&gt;&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-eureka-server --&gt;    &lt;!--导入Eureka Server依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--热部署工具--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application.yml</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 7001#Eureka配置eureka:  instance:    hostname: localhost #Eureka服务端的实例名字  client:    register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心    service-url: #监控页面~      #重写Eureka的默认端口以及访问路径 ---&gt;http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>源码中Eureka的默认端口以及访问路径:</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200521130439891.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<ol>
<li><p>主启动类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动之后，访问 http:&#x2F;&#x2F;localhost:7001&#x2F;@SpringBootApplication@EnableEurekaServer &#x2F;&#x2F;EnableEurekaServer 表示是 Eureka服务端的启动类，可以接受别人注册进来~public class EurekaServer_7001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServer_7001.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>启动成功后访问 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> 得到以下页面</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200521130420201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="2-eureka-client"><a href="#2-eureka-client" class="headerlink" title="2. eureka-client"></a>2. eureka-client</h5><p><strong>调整之前创建的springlouc-provider-dept-8001</strong></p>
<ol>
<li><p>导入Eureca依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Eureka依赖--&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-eureka --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>application中新增Eureca配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>
</li>
<li><p>为主启动类添加<a target="_blank" rel="noopener" href="https://github.com/EnableEurekaClient">@EnableEurekaClient</a>注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableEurekaClient &#x2F;&#x2F;EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务public class DeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptProvider_8001.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>先启动7001服务端后启动8001客户端进行测试，然后访问监控页<a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> 产看结果如图，成功</p>
<p><img src="https://img-blog.csdnimg.cn/20200521130507106.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>修改Eureka上的默认描述信息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      defaultZone: http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;  instance:    instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息</span><br></pre></td></tr></table></figure>

<p>结果如图：<br><img src="https://img-blog.csdnimg.cn/20200521130659314.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如果此时停掉springcloud-provider-dept-8001 等30s后 监控会开启保护机制<br><img src="https://img-blog.csdnimg.cn/20200521130557974.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
</li>
<li><p>配置关于服务加载的监控信息</p>
</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/20200521130718511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>pom.xml中添加依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--actuator完善监控信息--&gt;   &lt;dependency&gt;       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;       &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;   &lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>application.yml中添加配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#info配置   info:     app.name: haust-springcloud #项目的名称     company.name: com.haust #公司的名称</span><br></pre></td></tr></table></figure>

<p>此时刷新监控页，点击进入<img src="https://img-blog.csdnimg.cn/20200521130756988.png#pic_center" alt="在这里插入图片描述">跳转新页面显示如下内容：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521130814308.png#pic_center" alt="在这里插入图片描述"></p>
<h5 id="3-EureKa自我保护机制：好死不如赖活着"><a href="#3-EureKa自我保护机制：好死不如赖活着" class="headerlink" title="3. EureKa自我保护机制：好死不如赖活着"></a>3. EureKa自我保护机制：好死不如赖活着</h5><p>一句话总结就是：<strong>某时刻某一个微服务不可用，eureka不会立即清理，依旧会对该微服务的信息进行保存！</strong></p>
<ul>
<li>默认情况下，当eureka server在一定时间内没有收到实例的心跳，便会把该实例从注册表中删除（<strong>默认是90秒</strong>），但是，如果短时间内丢失大量的实例心跳，便会触发eureka server的自我保护机制，比如在开发测试时，需要频繁地重启微服务实例，但是我们很少会把eureka server一起重启（因为在开发过程中不会修改eureka注册中心），<strong>当一分钟内收到的心跳数大量减少时，会触发该保护机制</strong>。可以在eureka管理界面看到Renews threshold和Renews(last min)，当后者（最后一分钟收到的心跳数）小于前者（心跳阈值）的时候，触发保护机制，会出现红色的警告：**EMERGENCY!EUREKA MAY BE INCORRECTLY CLAIMING INSTANCES ARE UP WHEN THEY’RE NOT.RENEWALS ARE LESSER THAN THRESHOLD AND HENCE THE INSTANCES ARE NOT BEGING EXPIRED JUST TO BE SAFE.**从警告中可以看到，eureka认为虽然收不到实例的心跳，但它认为实例还是健康的，eureka会保护这些实例，不会把它们从注册表中删掉。</li>
<li>该保护机制的目的是避免网络连接故障，在发生网络故障时，微服务和注册中心之间无法正常通信，但服务本身是健康的，不应该注销该服务，如果eureka因网络故障而把微服务误删了，那即使网络恢复了，该微服务也不会重新注册到eureka server了，因为只有在微服务启动的时候才会发起注册请求，后面只会发送心跳和服务列表请求，这样的话，该实例虽然是运行着，但永远不会被其它服务所感知。所以，eureka server在短时间内丢失过多的客户端心跳时，会进入自我保护模式，该模式下，eureka会保护注册表中的信息，不在注销任何微服务，当网络故障恢复后，eureka会自动退出保护模式。自我保护模式可以让集群更加健壮。</li>
<li>但是我们在开发测试阶段，需要频繁地重启发布，如果触发了保护机制，则旧的服务实例没有被删除，这时请求有可能跑到旧的实例中，而该实例已经关闭了，这就导致请求错误，影响开发测试。所以，在开发测试阶段，我们可以把自我保护模式关闭，只需在eureka server配置文件中加上如下配置即可：<strong>eureka.server.enable-self-preservation=false</strong></li>
</ul>
<p>详细内容可以参考下这篇博客内容：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wudiyong22/article/details/80827594">https://blog.csdn.net/wudiyong22/article/details/80827594</a></p>
<h5 id="4-注册进来的微服务，获取一些消息（团队开发会用到）"><a href="#4-注册进来的微服务，获取一些消息（团队开发会用到）" class="headerlink" title="4. 注册进来的微服务，获取一些消息（团队开发会用到）"></a>4. 注册进来的微服务，获取一些消息（团队开发会用到）</h5><p>DeptController.java新增方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;获取一些配置的信息，得到具体的微服务！@Autowiredprivate DiscoveryClient client; &#x2F;&#x2F;注册进来的微服务~，获取一些消息~ @GetMapping(&quot;&#x2F;dept&#x2F;discovery&quot;) public Object discovery() &#123;     &#x2F;&#x2F;获取微服务列表的清单     List&lt;String&gt; services &#x3D; client.getServices();     System.out.println(&quot;discovery&#x3D;&gt;services:&quot; + services);     &#x2F;&#x2F;得到一个具体的微服务信息,通过具体的微服务id，applicaioinName；     List&lt;ServiceInstance&gt; instances &#x3D; client.getInstances(&quot;SPRINGCLOUD-PROVIDER-DEPT&quot;);     for (ServiceInstance instance : instances) &#123;         System.out.println(                 instance.getHost() + &quot;\t&quot; + &#x2F;&#x2F; 主机名称                         instance.getPort() + &quot;\t&quot; + &#x2F;&#x2F; 端口号                         instance.getUri() + &quot;\t&quot; + &#x2F;&#x2F; uri                         instance.getServiceId() &#x2F;&#x2F; 服务id         );     &#125;     return this.client; &#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200521130913485.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>主启动类中加入<a target="_blank" rel="noopener" href="https://github.com/EnableDiscoveryClient">@EnableDiscoveryClient</a> 注解</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableEurekaClient &#x2F;&#x2F;在服务启动后自动注册到Eureka中！@EnableDiscoveryClient &#x2F;&#x2F;服务发现~public class DeptProvider_8001 &#123;    ...&#125;</span><br></pre></td></tr></table></figure>

<p>结果如图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131043195.png#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200521131103616.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="5-4-Eureka：集群环境配置"><a href="#5-4-Eureka：集群环境配置" class="headerlink" title="5.4 Eureka：集群环境配置"></a>5.4 Eureka：集群环境配置</h4><h5 id="1-初始化"><a href="#1-初始化" class="headerlink" title="1.初始化"></a>1.初始化</h5><p>新建springcloud-eureka-7002、springcloud-eureka-7003 模块</p>
<p>1.为pom.xml添加依赖 (与springcloud-eureka-7001相同)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导包~--&gt;&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-eureka-server --&gt;    &lt;!--导入Eureka Server依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka-server&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--热部署工具--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>2.application.yml配置(与springcloud-eureka-7001相同)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 7003#Eureka配置eureka:  instance:    hostname: localhost #Eureka服务端的实例名字  client:    register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心    service-url: #监控页面~      #重写Eureka的默认端口以及访问路径 ---&gt;http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;      defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>3.主启动类(与springcloud-eureka-7001相同)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;启动之后，访问 http:&#x2F;&#x2F;localhost:7001&#x2F;@SpringBootApplication@EnableEurekaServer &#x2F;&#x2F;EnableEurekaServer 服务端的启动类，可以接受别人注册进来~public class EurekaServer_7003 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(EurekaServer_7003.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-集群成员相互关联"><a href="#2-集群成员相互关联" class="headerlink" title="2.集群成员相互关联"></a>2.集群成员相互关联</h5><p>配置一些自定义本机名字，找到本机hosts文件并打开</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131127278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>在hosts文件最后加上，要访问的本机名称，默认是localhost</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131141804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>修改application.yml的配置，如图为springcloud-eureka-7001配置，springcloud-eureka-7002/springcloud-eureka-7003同样分别修改为其对应的名称即可</p>
<p><img src="https://img-blog.csdnimg.cn/202005211312020.png#pic_center" alt="在这里插入图片描述"></p>
<p>在集群中使springcloud-eureka-7001关联springcloud-eureka-7002、springcloud-eureka-7003</p>
<p>完整的springcloud-eureka-7001下的application.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 7001#Eureka配置eureka:  instance:    hostname: eureka7001.com #Eureka服务端的实例名字  client:    register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心    service-url: #监控页面~      #重写Eureka的默认端口以及访问路径 ---&gt;http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;      # 单机： defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;      # 集群（关联）：7001关联7002、7003      defaultZone: http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>同时在集群中使springcloud-eureka-7002关联springcloud-eureka-7001、springcloud-eureka-7003</p>
<p>完整的springcloud-eureka-7002下的application.yml如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 7002#Eureka配置eureka:  instance:    hostname: eureka7002.com #Eureka服务端的实例名字  client:    register-with-eureka: false #表示是否向 Eureka 注册中心注册自己(这个模块本身是服务器,所以不需要)    fetch-registry: false #fetch-registry如果为false,则表示自己为注册中心    service-url: #监控页面~      #重写Eureka的默认端口以及访问路径 ---&gt;http:&#x2F;&#x2F;localhost:7001&#x2F;eureka&#x2F;      # 单机： defaultZone: http:&#x2F;&#x2F;$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;&#x2F;eureka&#x2F;      # 集群（关联）：7002关联7001、7003      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>springcloud-eureka-7003配置方式同理可得.</p>
<p>通过springcloud-provider-dept-8001下的yml配置文件，修改<strong>Eureka配置：配置服务注册中心地址</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      # 注册中心地址7001-7003      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;  instance:    instance-id: springcloud-provider-dept-8001 #修改Eureka上的默认描述信息</span><br></pre></td></tr></table></figure>

<p>这样模拟集群就搭建号了，就可以把一个项目挂载到三个服务器上了</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131237217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h4 id="5-5-对比和Zookeeper区别"><a href="#5-5-对比和Zookeeper区别" class="headerlink" title="5.5 对比和Zookeeper区别"></a>5.5 对比和Zookeeper区别</h4><h6 id="1-回顾CAP原则"><a href="#1-回顾CAP原则" class="headerlink" title="1. 回顾CAP原则"></a><strong>1. 回顾CAP原则</strong></h6><p>RDBMS (MySQL\Oracle\sqlServer) ===&gt; ACID</p>
<p>NoSQL (Redis\MongoDB) ===&gt; CAP</p>
<h6 id="2-ACID是什么？"><a href="#2-ACID是什么？" class="headerlink" title="2. ACID是什么？"></a><strong>2. ACID是什么？</strong></h6><ul>
<li>A (Atomicity) 原子性</li>
<li>C (Consistency) 一致性</li>
<li>I (Isolation) 隔离性</li>
<li>D (Durability) 持久性</li>
</ul>
<h6 id="3-CAP是什么"><a href="#3-CAP是什么" class="headerlink" title="3. CAP是什么?"></a><strong>3. CAP是什么?</strong></h6><ul>
<li>C (Consistency) 强一致性</li>
<li>A (Availability) 可用性</li>
<li>P (Partition tolerance) 分区容错性</li>
</ul>
<p>CAP的三进二：CA、AP、CP</p>
<h6 id="4-CAP理论的核心"><a href="#4-CAP理论的核心" class="headerlink" title="4. CAP理论的核心"></a><strong>4. CAP理论的核心</strong></h6><ul>
<li>一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求</li>
<li>根据CAP原理，将NoSQL数据库分成了满足CA原则，满足CP原则和满足AP原则三大类<ul>
<li>CA：单点集群，满足一致性，可用性的系统，通常可扩展性较差</li>
<li>CP：满足一致性，分区容错的系统，通常性能不是特别高</li>
<li>AP：满足可用性，分区容错的系统，通常可能对一致性要求低一些</li>
</ul>
</li>
</ul>
<h6 id="5-作为分布式服务注册中心，Eureka比Zookeeper好在哪里？"><a href="#5-作为分布式服务注册中心，Eureka比Zookeeper好在哪里？" class="headerlink" title="5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？"></a><strong>5. 作为分布式服务注册中心，Eureka比Zookeeper好在哪里？</strong></h6><p>著名的CAP理论指出，一个分布式系统不可能同时满足C (一致性) 、A (可用性) 、P (容错性)，由于分区容错性P再分布式系统中是必须要保证的，因此我们只能再A和C之间进行权衡。</p>
<ul>
<li>Zookeeper 保证的是CP</li>
<li>Eureka 保证的是AP</li>
</ul>
<p><strong>Zookeeper保证的是CP</strong></p>
<p> 当向注册中心查询服务列表时，我们可以容忍注册中心返回的是几分钟以前的注册信息，但不能接收服务直接down掉不可用。也就是说，<strong>服务注册功能对可用性的要求要高于一致性</strong>。但zookeeper会出现这样一种情况，当master节点因为网络故障与其他节点失去联系时，剩余节点会重新进行leader选举。问题在于，选举leader的时间太长，30-120s，且选举期间整个zookeeper集群是不可用的，这就导致在选举期间注册服务瘫痪。在云部署的环境下，因为网络问题使得zookeeper集群失去master节点是较大概率发生的事件，虽然服务最终能够恢复，但是，漫长的选举时间导致注册长期不可用，是不可容忍的。</p>
<p><strong>Eureka保证的是AP</strong></p>
<p> Eureka看明白了这一点，因此在设计时就优先保证可用性。<strong>Eureka各个节点都是平等的</strong>，几个节点挂掉不会影响正常节点的工作，剩余的节点依然可以提供注册和查询服务。而Eureka的客户端在向某个Eureka注册时，如果发现连接失败，则会自动切换至其他节点，只要有一台Eureka还在，就能保住注册服务的可用性，只不过查到的信息可能不是最新的，除此之外，Eureka还有之中自我保护机制，如果在15分钟内超过85%的节点都没有正常的心跳，那么Eureka就认为客户端与注册中心出现了网络故障，此时会出现以下几种情况：</p>
<ul>
<li>Eureka不在从注册列表中移除因为长时间没收到心跳而应该过期的服务</li>
<li>Eureka仍然能够接受新服务的注册和查询请求，但是不会被同步到其他节点上 (即保证当前节点依然可用)</li>
<li>当网络稳定时，当前实例新的注册信息会被同步到其他节点中</li>
</ul>
<p>因此，Eureka可以很好的应对因网络故障导致部分节点失去联系的情况，而不会像zookeeper那样使整个注册服务瘫痪</p>
<h3 id="6-Ribbon：负载均衡-基于客户端"><a href="#6-Ribbon：负载均衡-基于客户端" class="headerlink" title="6. Ribbon：负载均衡(基于客户端)"></a>6. Ribbon：负载均衡(基于客户端)</h3><h4 id="6-1-负载均衡以及Ribbon"><a href="#6-1-负载均衡以及Ribbon" class="headerlink" title="6.1 负载均衡以及Ribbon"></a>6.1 负载均衡以及Ribbon</h4><p><strong>Ribbon是什么？</strong></p>
<ul>
<li>Spring Cloud Ribbon 是基于Netflix Ribbon 实现的一套<strong>客户端负载均衡的工具</strong>。</li>
<li>简单的说，Ribbon 是 Netflix 发布的开源项目，主要功能是提供客户端的软件负载均衡算法，将 Netflix 的中间层服务连接在一起。Ribbon 的客户端组件提供一系列完整的配置项，如：连接超时、重试等。简单的说，就是在配置文件中列出 LoadBalancer (简称LB：负载均衡) 后面所有的及其，Ribbon 会自动的帮助你基于某种规则 (如简单轮询，随机连接等等) 去连接这些机器。我们也容易使用 Ribbon 实现自定义的负载均衡算法！</li>
</ul>
<p><strong>Ribbon能干嘛？</strong></p>
<ul>
<li>LB，即负载均衡 (LoadBalancer) ，在微服务或分布式集群中经常用的一种应用。</li>
<li>负载均衡简单的说就是将用户的请求平摊的分配到多个服务上，从而达到系统的HA (高用)。</li>
<li>常见的负载均衡软件有 Nginx、Lvs 等等。</li>
<li>Dubbo、SpringCloud 中均给我们提供了负载均衡，<strong>SpringCloud 的负载均衡算法可以自定义</strong>。</li>
<li>负载均衡简单分类：<ul>
<li>集中式LB<ul>
<li>即在服务的提供方和消费方之间使用独立的LB设施，如Nginx，由该设施负责把访问请求通过某种策略转发至服务的提供方！</li>
</ul>
</li>
<li>进程式LB<ul>
<li>将LB逻辑集成到消费方，消费方从服务注册中心获知有哪些地址可用，然后自己再从这些地址中选出一个合适的服务器。</li>
<li><strong>Ribbon 就属于进程内LB</strong>，它只是一个类库，集成于消费方进程，消费方通过它来获取到服务提供方的地址！</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>
<h4 id="6-2-集成Ribbon"><a href="#6-2-集成Ribbon" class="headerlink" title="6.2 集成Ribbon"></a>6.2 集成Ribbon</h4><p><strong>springcloud-consumer-dept-80</strong>向pom.xml中添加Ribbon和Eureka依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Ribbon--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--Eureka: Ribbon需要从Eureka服务中心获取要拿什么--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>在application.yml文件中配置Eureka</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># Eureka配置eureka:  client:    register-with-eureka: false # 不向 Eureka注册自己    service-url: # 从三个注册中心中随机取一个去访问      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;</span><br></pre></td></tr></table></figure>

<p>主启动类加上<a target="_blank" rel="noopener" href="https://github.com/EnableEurekaClient">@EnableEurekaClient</a>注解，开启Eureka</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号@SpringBootApplication@EnableEurekaClient &#x2F;&#x2F;开启Eureka 客户端public class DeptConsumer_80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumer_80.class, args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>自定义Spring配置类：ConfigBean.java 配置负载均衡实现RestTemplate</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Configurationpublic class ConfigBean &#123;&#x2F;&#x2F;@Configuration -- spring  applicationContext.xml    @LoadBalanced &#x2F;&#x2F;配置负载均衡实现RestTemplate    @Bean    public RestTemplate getRestTemplate() &#123;        return new RestTemplate();    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>修改conroller：DeptConsumerController.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问&#x2F;&#x2F;private static final String REST_URL_PREFIX &#x3D; &quot;http:&#x2F;&#x2F;localhost:8001&quot;;private static final String REST_URL_PREFIX &#x3D; &quot;http:&#x2F;&#x2F;SPRINGCLOUD-PROVIDER-DEPT&quot;;</span><br></pre></td></tr></table></figure>

<h4 id="6-3-使用Ribbon实现负载均衡"><a href="#6-3-使用Ribbon实现负载均衡" class="headerlink" title="6.3 使用Ribbon实现负载均衡"></a>6.3 使用Ribbon实现负载均衡</h4><p>流程图：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131315626.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>1.新建两个服务提供者Moudle：springcloud-provider-dept-8003、springcloud-provider-dept-8002</p>
<p>2.参照springcloud-provider-dept-8001 依次为另外两个Moudle添加pom.xml依赖 、resourece下的mybatis和application.yml配置，Java代码</p>
<p>3.启动所有服务测试(根据自身电脑配置决定启动服务的个数)，访问<a target="_blank" rel="noopener" href="http://eureka7001.com:7002/%E6%9F%A5%E7%9C%8B%E7%BB%93%E6%9E%9C">http://eureka7001.com:7002/查看结果</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521131332466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>测试访问<a target="_blank" rel="noopener" href="http://localhost/consumer/dept/list">http://localhost/consumer/dept/list</a> 这时候随机访问的是服务提供者8003</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131413295.png#pic_center" alt="在这里插入图片描述"></p>
<p>再次访问<a target="_blank" rel="noopener" href="http://localhost/consumer/dept/list%E8%BF%99%E6%97%B6%E5%80%99%E9%9A%8F%E6%9C%BA%E7%9A%84%E6%98%AF%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%858001">http://localhost/consumer/dept/list这时候随机的是服务提供者8001</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521131431716.png#pic_center" alt="在这里插入图片描述"></p>
<p>以上这种<strong>每次访问<a target="_blank" rel="noopener" href="http://localhost/consumer/dept/list%E9%9A%8F%E6%9C%BA%E8%AE%BF%E9%97%AE%E9%9B%86%E7%BE%A4%E4%B8%AD%E6%9F%90%E4%B8%AA%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%EF%BC%8C%E8%BF%99%E7%A7%8D%E6%83%85%E5%86%B5%E5%8F%AB%E5%81%9A%E8%BD%AE%E8%AF%A2">http://localhost/consumer/dept/list随机访问集群中某个服务提供者，这种情况叫做轮询</a></strong>，轮询算法在SpringCloud中可以自定义。</p>
<p><strong>如何切换或者自定义规则呢？</strong></p>
<p>在springcloud-provider-dept-80模块下的ConfigBean中进行配置，切换使用不同的规则</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Configurationpublic class ConfigBean &#123;&#x2F;&#x2F;@Configuration -- spring  applicationContext.xml    &#x2F;**     * IRule:     * RoundRobinRule 轮询     * RandomRule 随机     * AvailabilityFilteringRule ： 会先过滤掉，跳闸，访问故障的服务~，对剩下的进行轮询~     * RetryRule ： 会先按照轮询获取服务~，如果服务获取失败，则会在指定的时间内进行，重试     *&#x2F;    @LoadBalanced &#x2F;&#x2F;配置负载均衡实现RestTemplate    @Bean    public RestTemplate getRestTemplate() &#123;        return new RestTemplate();    &#125;    @Bean    public IRule myRule()&#123;        return new RandomRule();&#x2F;&#x2F;使用随机规则    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以自定义规则，在myRule包下自定义一个配置类MyRule.java，注意：<strong>该包不要和主启动类所在的包同级，要跟启动类所在包同级</strong>：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131456478.png#pic_center" alt="在这里插入图片描述"></p>
<p>MyRule.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;** * @Auther: csp1999 * @Date: 2020&#x2F;05&#x2F;19&#x2F;11:58 * @Description: 自定义规则 *&#x2F;@Configurationpublic class MyRule &#123;    @Bean    public IRule myRule()&#123;        return new MyRandomRule();&#x2F;&#x2F;默认是轮询RandomRule,现在自定义为自己的    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>主启动类开启负载均衡并指定自定义的MyRule配置类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;Ribbon 和 Eureka 整合以后，客户端可以直接调用，不用关心IP地址和端口号@SpringBootApplication@EnableEurekaClient&#x2F;&#x2F;在微服务启动的时候就能加载自定义的Ribbon类(自定义的规则会覆盖原有默认的规则)@RibbonClient(name &#x3D; &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,configuration &#x3D; MyRule.class)&#x2F;&#x2F;开启负载均衡,并指定自定义的规则public class DeptConsumer_80 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumer_80.class, args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>自定义的规则(这里我们参考Ribbon中默认的规则代码自己稍微改动)：MyRandomRule.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public class MyRandomRule extends AbstractLoadBalancerRule &#123;    &#x2F;**     * 每个服务访问5次则换下一个服务(总共3个服务)     * &lt;p&gt;     * total&#x3D;0,默认&#x3D;0,如果&#x3D;5,指向下一个服务节点     * index&#x3D;0,默认&#x3D;0,如果total&#x3D;5,index+1     *&#x2F;    private int total &#x3D; 0;&#x2F;&#x2F;被调用的次数    private int currentIndex &#x3D; 0;&#x2F;&#x2F;当前是谁在提供服务    &#x2F;&#x2F;@edu.umd.cs.findbugs.annotations.SuppressWarnings(value &#x3D; &quot;RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE&quot;)    public Server choose(ILoadBalancer lb, Object key) &#123;        if (lb &#x3D;&#x3D; null) &#123;            return null;        &#125;        Server server &#x3D; null;        while (server &#x3D;&#x3D; null) &#123;            if (Thread.interrupted()) &#123;                return null;            &#125;            List&lt;Server&gt; upList &#x3D; lb.getReachableServers();&#x2F;&#x2F;获得当前活着的服务            List&lt;Server&gt; allList &#x3D; lb.getAllServers();&#x2F;&#x2F;获取所有的服务            int serverCount &#x3D; allList.size();            if (serverCount &#x3D;&#x3D; 0) &#123;                &#x2F;*                 * No servers. End regardless of pass, because subsequent passes                 * only get more restrictive.                 *&#x2F;                return null;            &#125;            &#x2F;&#x2F;int index &#x3D; chooseRandomInt(serverCount);&#x2F;&#x2F;生成区间随机数            &#x2F;&#x2F;server &#x3D; upList.get(index);&#x2F;&#x2F;从或活着的服务中,随机获取一个            &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;自定义代码&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;            if (total &lt; 5) &#123;                server &#x3D; upList.get(currentIndex);                total++;            &#125; else &#123;                total &#x3D; 0;                currentIndex++;                if (currentIndex &gt; upList.size()) &#123;                    currentIndex &#x3D; 0;                &#125;                server &#x3D; upList.get(currentIndex);&#x2F;&#x2F;从活着的服务中,获取指定的服务来进行操作            &#125;            &#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;            if (server &#x3D;&#x3D; null) &#123;                &#x2F;*                 * The only time this should happen is if the server list were                 * somehow trimmed. This is a transient condition. Retry after                 * yielding.                 *&#x2F;                Thread.yield();                continue;            &#125;            if (server.isAlive()) &#123;                return (server);            &#125;            &#x2F;&#x2F; Shouldn&#39;t actually happen.. but must be transient or a bug.            server &#x3D; null;            Thread.yield();        &#125;        return server;    &#125;    protected int chooseRandomInt(int serverCount) &#123;        return ThreadLocalRandom.current().nextInt(serverCount);    &#125;    @Override    public Server choose(Object key) &#123;        return choose(getLoadBalancer(), key);    &#125;    @Override    public void initWithNiwsConfig(IClientConfig clientConfig) &#123;        &#x2F;&#x2F; TODO Auto-generated method stub    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="7-Feign：负载均衡-基于服务端"><a href="#7-Feign：负载均衡-基于服务端" class="headerlink" title="7.Feign：负载均衡(基于服务端)"></a>7.Feign：负载均衡(基于服务端)</h3><h4 id="7-1-Feign简介"><a href="#7-1-Feign简介" class="headerlink" title="7.1 Feign简介"></a>7.1 Feign简介</h4><p>Feign是声明式Web Service客户端，它让微服务之间的调用变得更简单，类似controller调用service。SpringCloud集成了Ribbon和Eureka，可以使用Feigin提供负载均衡的http客户端</p>
<p><strong>只需要创建一个接口，然后添加注解即可~</strong></p>
<p>Feign，主要是社区版，大家都习惯面向接口编程。这个是很多开发人员的规范。调用微服务访问两种方法</p>
<ol>
<li>微服务名字 【ribbon】</li>
<li>接口和注解 【feign】</li>
</ol>
<p><strong>Feign能干什么？</strong></p>
<ul>
<li>Feign旨在使编写Java Http客户端变得更容易</li>
<li>前面在使用Ribbon + RestTemplate时，利用RestTemplate对Http请求的封装处理，形成了一套模板化的调用方法。但是在实际开发中，由于对服务依赖的调用可能不止一处，往往一个接口会被多处调用，所以通常都会针对每个微服务自行封装一个客户端类来包装这些依赖服务的调用。所以，Feign在此基础上做了进一步的封装，由他来帮助我们定义和实现依赖服务接口的定义，在Feign的实现下，我们只需要创建一个接口并使用注解的方式来配置它 (类似以前Dao接口上标注Mapper注解，现在是一个微服务接口上面标注一个Feign注解)，即可完成对服务提供方的接口绑定，简化了使用Spring Cloud Ribbon 时，自动封装服务调用客户端的开发量。</li>
</ul>
<p><strong>Feign默认集成了Ribbon</strong></p>
<ul>
<li>利用Ribbon维护了MicroServiceCloud-Dept的服务列表信息，并且通过轮询实现了客户端的负载均衡，而与Ribbon不同的是，通过Feign只需要定义服务绑定接口且以声明式的方法，优雅而简单的实现了服务调用。</li>
</ul>
<h4 id="7-2-Feign的使用步骤"><a href="#7-2-Feign的使用步骤" class="headerlink" title="7.2 Feign的使用步骤"></a>7.2 Feign的使用步骤</h4><ol>
<li><p>创建springcloud-consumer-fdept-feign模块</p>
<p>拷贝springcloud-consumer-dept-80模块下的pom.xml，resource，以及java代码到springcloud-consumer-feign模块，并添加feign依赖。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Feign的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-feign&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>通过Ribbon实现：—-原来的controller：DeptConsumerController.java</p>
<p>```java<br>package com.haust.springcloud.controller;</p>
<p>import com.haust.springcloud.pojo.Dept;<br>import org.springframework.beans.factory.annotation.Autowired;<br>import org.springframework.web.bind.annotation.PathVariable;<br>import org.springframework.web.bind.annotation.RequestMapping;<br>import org.springframework.web.bind.annotation.RestController;<br>import org.springframework.web.client.RestTemplate;</p>
<p>import java.util.List;</p>
<p>/**</p>
<ul>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Auther">@Auther</a>: csp1999</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Date">@Date</a>: 2020/05/17/22:44</p>
</li>
<li><p><a target="_blank" rel="noopener" href="https://github.com/Description">@Description</a>:<br>*/<br><a target="_blank" rel="noopener" href="https://github.com/RestController">@RestController</a><br>public class DeptConsumerController {</p>
<p>// 理解：消费者，不应该有service层~<br>// RestTemplate …. 供我们直接调用就可以了！ 注册到Spring中<br>// (url, 实体：Map ,Class responseType)<br><a target="_blank" rel="noopener" href="https://github.com/Autowired">@Autowired</a><br>private RestTemplate restTemplate; //提供多种便捷访问远程http服务的方法，简单的Restful服务模板~</p>
<p>//Ribbon:我们这里的地址，应该是一个变量，通过服务名来访问<br>//private static final String REST_URL_PREFIX = “<a target="_blank" rel="noopener" href="http://localhost:8001/">http://localhost:8001</a>“;<br>private static final String REST_URL_PREFIX = “<a target="_blank" rel="noopener" href="http://springcloud-provider-dept/">http://SPRINGCLOUD-PROVIDER-DEPT</a>“;</p>
<p><a target="_blank" rel="noopener" href="https://github.com/RequestMapping">@RequestMapping</a>(“/consumer/dept/add”)<br>public boolean add(Dept dept) {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return restTemplate.postForObject(REST_URL_PREFIX + &quot;&#x2F;dept&#x2F;add&quot;, dept, Boolean.class);</span><br></pre></td></tr></table></figure>

<p>}</p>
<p><a target="_blank" rel="noopener" href="https://github.com/RequestMapping">@RequestMapping</a>(“/consumer/dept/get/{id}”)<br>public Dept get(<a target="_blank" rel="noopener" href="https://github.com/PathVariable">@PathVariable</a>(“id”) Long id) {</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return restTemplate.getForObject(REST_URL_PREFIX + &quot;&#x2F;dept&#x2F;get&#x2F;&quot; + id, Dept.class);</span><br></pre></td></tr></table></figure>

<p>}</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;list&quot;)   public List&lt;Dept&gt; list() &#123;       return restTemplate.getForObject(REST_URL_PREFIX + &quot;&#x2F;dept&#x2F;list&quot;, List.class);   &#125;</span><br></pre></td></tr></table></figure>

<p>}</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">通过Feign实现：---改造后controller：DeptConsumerController.java   &#96;&#96;&#96;java   @RestController   public class DeptConsumerController &#123;       @Autowired       private DeptClientService deptClientService &#x3D; null;       @RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;add&quot;)       public boolean add(Dept dept) &#123;           return this.deptClientService.addDept(dept);       &#125;       @RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;get&#x2F;&#123;id&#125;&quot;)       public Dept get(@PathVariable(&quot;id&quot;) Long id) &#123;          return this.deptClientService.queryById(id);       &#125;       @RequestMapping(&quot;&#x2F;consumer&#x2F;dept&#x2F;list&quot;)       public List&lt;Dept&gt; list() &#123;           return this.deptClientService.queryAll();       &#125;   &#125;</span><br></pre></td></tr></table></figure>

<p>Feign和Ribbon二者对比，前者显现出面向接口编程特点，代码看起来更清爽</p>
<p>主配置类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication   @EnableEurekaClient   &#x2F;&#x2F;feign客户端注解,并指定要扫描的包以及配置接口DeptClientService   @EnableFeignClients(basePackages &#x3D; &#123;&quot;com.haust.springcloud&quot;&#125;)   &#x2F;&#x2F;扫描所有自己的包,让所有注解也能生效   @ComponentScan(&quot;com.haust.springcloud&quot;)   public class FeignDeptConsumer_80 &#123;       public static void main(String[] args) &#123;           SpringApplication.run(FeignDeptConsumer_80.class, args);       &#125;   &#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>改造springcloud-api模块</p>
<p>pom.xml添加feign依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Feign的依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-feign&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>新建service包，并新建DeptClientService.java接口，</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务@FeignClient(value &#x3D; &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;)public interface DeptClientService &#123;    @GetMapping(&quot;&#x2F;dept&#x2F;get&#x2F;&#123;id&#125;&quot;)    public Dept queryById(@PathVariable(&quot;id&quot;) Long id);    @GetMapping(&quot;&#x2F;dept&#x2F;list&quot;)    public Dept queryAll();    @GetMapping(&quot;&#x2F;dept&#x2F;add&quot;)    public Dept addDept(Dept dept);&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h4 id="7-3-Feign和Ribbon如何选择？"><a href="#7-3-Feign和Ribbon如何选择？" class="headerlink" title="7.3 Feign和Ribbon如何选择？"></a>7.3 Feign和Ribbon如何选择？</h4><p><strong>根据个人习惯而定，如果喜欢REST风格使用Ribbon；如果喜欢社区版的面向接口风格使用Feign.</strong></p>
<h2 id="8-Hystrix：服务熔断"><a href="#8-Hystrix：服务熔断" class="headerlink" title="8. Hystrix：服务熔断"></a>8. Hystrix：服务熔断</h2><p><strong>分布式系统面临的问题</strong></p>
<p>复杂分布式体系结构中的应用程序有数十个依赖关系，每个依赖关系在某些时候将不可避免失败！</p>
<h4 id="8-1-服务雪崩"><a href="#8-1-服务雪崩" class="headerlink" title="8.1 服务雪崩"></a>8.1 服务雪崩</h4><p> 多个微服务之间调用的时候，假设微服务A调用微服务B和微服务C，微服务B和微服务C又调用其他的微服务，这就是所谓的“扇出”，如果扇出的链路上<strong>某个微服务的调用响应时间过长，或者不可用</strong>，对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，所谓的“雪崩效应”。</p>
<p> 对于高流量的应用来说，单一的后端依赖可能会导致所有服务器上的所有资源都在几十秒内饱和。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，备份队列，线程和其他系统资源紧张，导致整个系统发生更多的级联故障，这些都表示需要对故障和延迟进行隔离和管理，以便单个依赖关系的失败，不能取消整个应用程序或系统。</p>
<p> <strong>我们需要，弃车保帅</strong></p>
<h4 id="8-2-什么是Hystrix？"><a href="#8-2-什么是Hystrix？" class="headerlink" title="8.2 什么是Hystrix？"></a>8.2 什么是Hystrix？</h4><p> Hystrix是一个应用于处理分布式系统的延迟和容错的开源库，在分布式系统里，许多依赖不可避免的会调用失败，比如超时，异常等，Hystrix能够保证在一个依赖出问题的情况下，不会导致整个体系服务失败，避免级联故障，以提高分布式系统的弹性。</p>
<p> “断路器”本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控 (类似熔断保险丝) ，<strong>向调用方方茴一个服务预期的，可处理的备选响应 (FallBack) ，而不是长时间的等待或者抛出调用方法无法处理的异常，这样就可以保证了服务调用方的线程不会被长时间，不必要的占用</strong>，从而避免了故障在分布式系统中的蔓延，乃至雪崩。</p>
<h4 id="8-3-Hystrix能干嘛？"><a href="#8-3-Hystrix能干嘛？" class="headerlink" title="8.3 Hystrix能干嘛？"></a>8.3 Hystrix能干嘛？</h4><ul>
<li>服务降级</li>
<li>服务熔断</li>
<li>服务限流</li>
<li>接近实时的监控</li>
<li>…</li>
</ul>
<p>当一切正常时，请求流可以如下所示：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvSHlzdHJpeC93aWtpL2ltYWdlcy9zb2EtMS02NDAucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>当许多后端系统中有一个潜在时，它可以阻止整个用户请求：</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvSHlzdHJpeC93aWtpL2ltYWdlcy9zb2EtMi02NDAucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>随着大容量通信量的增加，单个后端依赖项的潜在性会导致所有服务器上的所有资源在几秒钟内饱和。</p>
<p>应用程序中通过网络或客户端库可能导致网络请求的每个点都是潜在故障的来源。比失败更糟糕的是，这些应用程序还可能导致服务之间的延迟增加，从而备份队列、线程和其他系统资源，从而导致更多跨系统的级联故障。</p>
<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRodWIuY29tL05ldGZsaXgvSHlzdHJpeC93aWtpL2ltYWdlcy9zb2EtMy02NDAucG5n?x-oss-process=image/format,png" alt="img"></p>
<p>当使用hystrix包装每个基础依赖项时，上面的图表中所示的体系结构会发生类似于以下关系图的变化。每个依赖项是相互隔离的，限制在延迟发生时它可以填充的资源中，并包含在回退逻辑中，该逻辑决定在依赖项中发生任何类型的故障时要做出什么样的响应：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131820586.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>官网资料</strong>：<a target="_blank" rel="noopener" href="https://github.com/Netflix/Hystrix/wiki">https://github.com/Netflix/Hystrix/wiki</a></p>
<h4 id="8-4-服务熔断"><a href="#8-4-服务熔断" class="headerlink" title="8.4 服务熔断"></a>8.4 服务熔断</h4><h5 id="什么是服务熔断"><a href="#什么是服务熔断" class="headerlink" title="什么是服务熔断"></a><strong>什么是服务熔断</strong></h5><p> 熔断机制是赌赢雪崩效应的一种微服务链路保护机制。</p>
<p> 在微服务架构中，微服务之间的数据交互通过远程调用完成，微服务A调用微服务B和微服务C，微服务B和微服务C又调用其它的微服务，此时如果链路上某个微服务的调用响应时间过长或者不可用，那么对微服务A的调用就会占用越来越多的系统资源，进而引起系统崩溃，导致“雪崩效应”。</p>
<p>  服务熔断是应对雪崩效应的一种微服务链路保护机制。例如在高压电路中，如果某个地方的电压过高，熔断器就会熔断，对电路进行保护。同样，在微服务架构中，熔断机制也是起着类似的作用。当调用链路的某个微服务不可用或者响应时间太长时，会进行服务熔断，不再有该节点微服务的调用，快速返回错误的响应信息。当检测到该节点微服务调用响应正常后，恢复调用链路。</p>
<p> 当扇出链路的某个微服务不可用或者响应时间太长时，会进行服务的降级，<strong>进而熔断该节点微服务的调用，快速返回错误的响应信息</strong>。检测到该节点微服务调用响应正常后恢复调用链路。在SpringCloud框架里熔断机制通过Hystrix实现。Hystrix会监控微服务间调用的状况，当失败的调用到一定阀值缺省是5秒内20次调用失败，就会启动熔断机制。熔断机制的注解是：**<a target="_blank" rel="noopener" href="https://github.com/HystrixCommand">@HystrixCommand</a>** 。</p>
<p> 服务熔断解决如下问题： 1. 当所依赖的对象不稳定时，能够起到快速失败的目的；2. 快速失败后，能够根据一定的算法动态试探所依赖对象是否恢复。</p>
<h5 id="入门案例"><a href="#入门案例" class="headerlink" title="入门案例"></a>入门案例</h5><p>新建springcloud-provider-dept-hystrix-8001模块并拷贝springcloud-provider-dept—8001内的pom.xml、resource和Java代码进行初始化并调整。</p>
<p><strong>导入hystrix依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--导入Hystrix依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>调整yml配置文件</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 8001# mybatis配置mybatis:  # springcloud-api 模块下的pojo包  type-aliases-package: com.haust.springcloud.pojo  # 本模块下的mybatis-config.xml核心配置文件类路径  config-location: classpath:mybatis&#x2F;mybatis-config.xml  # 本模块下的mapper配置文件类路径  mapper-locations: classpath:mybatis&#x2F;mapper&#x2F;*.xml# spring配置spring:  application:    #项目名    name: springcloud-provider-dept  datasource:    # 德鲁伊数据源    type: com.alibaba.druid.pool.DruidDataSource    driver-class-name: com.mysql.jdbc.Driver    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;db01?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf-8    username: root    password: root# Eureka配置：配置服务注册中心地址eureka:  client:    service-url:      # 注册中心地址7001-7003      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;  instance:    instance-id: springcloud-provider-dept-hystrix-8001 #修改Eureka上的默认描述信息    prefer-ip-address: true #改为true后默认显示的是ip地址而不再是localhost#info配置info:  app.name: haust-springcloud #项目的名称  company.name: com.haust #公司的名称</span><br></pre></td></tr></table></figure>

<p>prefer-ip-address: false:</p>
<p><img src="https://img-blog.csdnimg.cn/20200521131940911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>prefer-ip-address: true：</p>
<p><img src="https://img-blog.csdnimg.cn/2020052113195798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><strong>修改controller</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;提供Restful服务@RestControllerpublic class DeptController &#123;    @Autowired    private DeptService deptService;    @HystrixCommand(fallbackMethod &#x3D; &quot;hystrixGet&quot;)&#x2F;&#x2F;如果根据id查询出现异常,走这段代码    @GetMapping(&quot;&#x2F;dept&#x2F;get&#x2F;&#123;id&#125;&quot;)&#x2F;&#x2F;根据id查询    public Dept get(@PathVariable(&quot;id&quot;) Long id)&#123;        Dept dept &#x3D; deptService.queryById(id);        if (dept&#x3D;&#x3D;null)&#123;            throw new RuntimeException(&quot;这个id&#x3D;&gt;&quot;+id+&quot;,不存在该用户，或信息无法找到~&quot;);        &#125;        return dept;    &#125;    &#x2F;&#x2F;根据id查询备选方案(熔断)    public Dept hystrixGet(@PathVariable(&quot;id&quot;) Long id)&#123;        return new Dept().setDeptno(id)                .setDname(&quot;这个id&#x3D;&gt;&quot;+id+&quot;,没有对应的信息,null---@Hystrix~&quot;)                .setDb_source(&quot;在MySQL中没有这个数据库&quot;);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>为主启动类添加对熔断的支持注解<a target="_blank" rel="noopener" href="https://github.com/EnableCircuitBreaker">@EnableCircuitBreaker</a></strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableEurekaClient &#x2F;&#x2F;EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务@EnableCircuitBreaker&#x2F;&#x2F;添加对熔断的支持注解public class HystrixDeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(HystrixDeptProvider_8001.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>测试</strong>：</p>
<p>使用熔断后，当访问一个不存在的id时，前台页展示数据如下</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132057247.png#pic_center" alt="在这里插入图片描述"></p>
<p>而不适用熔断的springcloud-provider-dept—8001模块访问相同地址会出现下面状况</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132119757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>因此，<strong>为了避免因某个微服务后台出现异常或错误而导致整个应用或网页报错，使用熔断是必要的</strong></p>
<h4 id="8-5-服务降级"><a href="#8-5-服务降级" class="headerlink" title="8.5 服务降级"></a>8.5 服务降级</h4><h5 id="什么是服务降级"><a href="#什么是服务降级" class="headerlink" title="什么是服务降级"></a>什么是服务降级</h5><p> 服务降级是指 当服务器压力剧增的情况下，根据实际业务情况及流量，对一些服务和页面有策略的不处理或换种简单的方式处理，从而释放服务器资源以保证核心业务正常运作或高效运作。说白了，就是尽可能的把系统资源让给优先级高的服务。<br>  资源有限，而请求是无限的。如果在并发高峰期，不做服务降级处理，一方面肯定会影响整体服务的性能，严重的话可能会导致宕机某些重要的服务不可用。所以，一般在高峰期，为了保证核心功能服务的可用性，都要对某些服务降级处理。比如当双11活动时，把交易无关的服务统统降级，如查看蚂蚁深林，查看历史订单等等。</p>
<p>  服务降级主要用于什么场景呢？当整个微服务架构整体的负载超出了预设的上限阈值或即将到来的流量预计将会超过预设的阈值时，为了保证重要或基本的服务能正常运行，可以将一些 不重要 或 不紧急 的服务或任务进行服务的 延迟使用 或 暂停使用。<br>  降级的方式可以根据业务来，可以延迟服务，比如延迟给用户增加积分，只是放到一个缓存中，等服务平稳之后再执行 ；或者在粒度范围内关闭服务，比如关闭相关文章的推荐。</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132141732.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>由上图可得，<strong>当某一时间内服务A的访问量暴增，而B和C的访问量较少，为了缓解A服务的压力，这时候需要B和C暂时关闭一些服务功能，去承担A的部分服务，从而为A分担压力，叫做服务降级</strong>。</p>
<h5 id="服务降级需要考虑的问题"><a href="#服务降级需要考虑的问题" class="headerlink" title="服务降级需要考虑的问题"></a>服务降级需要考虑的问题</h5><ul>
<li>1）那些服务是核心服务，哪些服务是非核心服务</li>
<li>2）那些服务可以支持降级，那些服务不能支持降级，降级策略是什么</li>
<li>3）除服务降级之外是否存在更复杂的业务放通场景，策略是什么？</li>
</ul>
<h5 id="自动降级分类"><a href="#自动降级分类" class="headerlink" title="自动降级分类"></a>自动降级分类</h5><p>  1）超时降级：主要配置好超时时间和超时重试次数和机制，并使用异步机制探测回复情况</p>
<p>  2）失败次数降级：主要是一些不稳定的api，当失败调用次数达到一定阀值自动降级，同样要使用异步机制探测回复情况</p>
<p>  3）故障降级：比如要调用的远程服务挂掉了（网络故障、DNS故障、http服务返回错误的状态码、rpc服务抛出异常），则可以直接降级。降级后的处理方案有：默认值（比如库存服务挂了，返回默认现货）、兜底数据（比如广告挂了，返回提前准备好的一些静态页面）、缓存（之前暂存的一些缓存数据）</p>
<p>  4）限流降级：秒杀或者抢购一些限购商品时，此时可能会因为访问量太大而导致系统崩溃，此时会使用限流来进行限制访问量，当达到限流阀值，后续请求会被降级；降级后的处理方案可以是：排队页面（将用户导流到排队页面等一会重试）、无货（直接告知用户没货了）、错误页（如活动太火爆了，稍后重试）。</p>
<h5 id="入门案例-1"><a href="#入门案例-1" class="headerlink" title="入门案例"></a>入门案例</h5><p>在springcloud-api模块下的service包中新建降级配置类DeptClientServiceFallBackFactory.java</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;降级 ~@Componentpublic class DeptClientServiceFallBackFactory implements FallbackFactory &#123;    @Override    public DeptClientService create(Throwable cause) &#123;        return new DeptClientService() &#123;            @Override            public Dept queryById(Long id) &#123;                return new Dept()                        .setDeptno(id)                        .setDname(&quot;id&#x3D;&gt;&quot; + id + &quot;没有对应的信息，客户端提供了降级的信息，这个服务现在已经被关闭&quot;)                        .setDb_source(&quot;没有数据~&quot;);            &#125;            @Override            public List&lt;Dept&gt; queryAll() &#123;                return null;            &#125;            @Override            public Boolean addDept(Dept dept) &#123;                return false;            &#125;        &#125;;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>在DeptClientService中指定降级配置类DeptClientServiceFallBackFactory</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Component &#x2F;&#x2F;注册到spring容器中&#x2F;&#x2F;@FeignClient:微服务客户端注解,value:指定微服务的名字,这样就可以使Feign客户端直接找到对应的微服务@FeignClient(value &#x3D; &quot;SPRINGCLOUD-PROVIDER-DEPT&quot;,fallbackFactory &#x3D; DeptClientServiceFallBackFactory.class)&#x2F;&#x2F;fallbackFactory指定降级配置类public interface DeptClientService &#123;    @GetMapping(&quot;&#x2F;dept&#x2F;get&#x2F;&#123;id&#125;&quot;)    public Dept queryById(@PathVariable(&quot;id&quot;) Long id);    @GetMapping(&quot;&#x2F;dept&#x2F;list&quot;)    public List&lt;Dept&gt; queryAll();    @GetMapping(&quot;&#x2F;dept&#x2F;add&quot;)    public Boolean addDept(Dept dept);&#125;</span><br></pre></td></tr></table></figure>

<p>在springcloud-consumer-dept-feign模块中开启降级</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 80# Eureka配置eureka:  client:    register-with-eureka: false # 不向 Eureka注册自己    service-url: # 从三个注册中心中随机取一个去访问      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;# 开启降级feign.hystrixfeign:  hystrix:    enabled: true</span><br></pre></td></tr></table></figure>

<h4 id="8-6-服务熔断和降级的区别"><a href="#8-6-服务熔断和降级的区别" class="headerlink" title="8.6 服务熔断和降级的区别"></a>8.6 服务熔断和降级的区别</h4><ul>
<li><strong>服务熔断—-&gt;服务端</strong>：某个服务超时或异常，引起熔断~，类似于保险丝(自我熔断)</li>
<li><strong>服务降级—-&gt;客户端</strong>：从整体网站请求负载考虑<del>，当某个服务熔断或者关闭之后，服务将不再被调用</del>，此时在客户端，我们可以准备一个 FallBackFactory ，返回一个默认的值(缺省值)。会导致整体的服务下降，但是好歹能用，比直接挂掉强。</li>
<li>触发原因不太一样，服务熔断一般是某个服务（下游服务）故障引起，而服务降级一般是从整体负荷考虑；管理目标的层次不太一样，熔断其实是一个框架级的处理，每个微服务都需要（无层级之分），而降级一般需要对业务有层级之分（比如降级一般是从最外围服务开始）</li>
<li>实现方式不太一样，服务降级具有代码侵入性(由控制器完成/或自动降级)，熔断一般称为<strong>自我熔断</strong>。</li>
</ul>
<p>限流：限制并发的请求访问量，超过阈值则拒绝；<br>降级：服务分优先级，牺牲非核心服务（不可用），保证核心服务稳定；从整体负荷考虑；<br>熔断：依赖的下游服务故障触发熔断，避免引发本系统崩溃；系统自动执行和恢复</p>
<h4 id="8-7-Dashboard-流监控"><a href="#8-7-Dashboard-流监控" class="headerlink" title="8.7 Dashboard 流监控"></a>8.7 Dashboard 流监控</h4><p>新建springcloud-consumer-hystrix-dashboard模块</p>
<p><strong>添加依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--Hystrix依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifact    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--dashboard依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboard&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--Ribbon--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;&#x2F;artifactI    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--Eureka--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactI    &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!--实体类+web--&gt;&lt;dependency&gt;    &lt;groupId&gt;com.haust&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;springcloud-api&lt;&#x2F;artifactId&gt;    &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;!--热部署--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p><strong>主启动类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication&#x2F;&#x2F;开启Dashboard@EnableHystrixDashboardpublic class DeptConsumerDashboard_9001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptConsumerDashboard_9001.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>给springcloud-provider-dept-8001模块下的主启动类添加如下代码,添加监控</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableEurekaClient &#x2F;&#x2F;EnableEurekaClient 客户端的启动类，在服务启动后自动向注册中心注册服务public class DeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(DeptProvider_8001.class,args);    &#125;    &#x2F;&#x2F;增加一个 Servlet    @Bean    public ServletRegistrationBean hystrixMetricsStreamServlet()&#123;        ServletRegistrationBean registrationBean &#x3D; new ServletRegistrationBean(new HystrixMetricsStreamServlet());        &#x2F;&#x2F;访问该页面就是监控页面        registrationBean.addUrlMappings(&quot;&#x2F;actuator&#x2F;hystrix.stream&quot;);        return registrationBean;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="9-Zull路由网关"><a href="#9-Zull路由网关" class="headerlink" title="9. Zull路由网关"></a>9. Zull路由网关</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><strong>什么是zuul?</strong></p>
<p> Zull包含了对请求的<strong>路由</strong>(用来跳转的)和<strong>过滤</strong>两个最主要功能：</p>
<p> 其中<strong>路由功能负责将外部请求转发到具体的微服务实例上，是实现外部访问统一入口的基础</strong>，而过<strong>滤器功能则负责对请求的处理过程进行干预，是实现请求校验，服务聚合等功能的基础</strong>。Zuul和Eureka进行整合，将Zuul自身注册为Eureka服务治理下的应用，同时从Eureka中获得其他服务的消息，也即以后的访问微服务都是通过Zuul跳转后获得。</p>
<p> 注意：Zuul服务最终还是会注册进Eureka</p>
<p> 提供：代理+路由+过滤 三大功能！</p>
<p><strong>Zuul能干嘛？</strong></p>
<ul>
<li>路由</li>
<li>过滤</li>
</ul>
<p>官方文档：<a target="_blank" rel="noopener" href="https://github.com/Netflix/zuul/">https://github.com/Netflix/zuul/</a></p>
<h4 id="入门案例-2"><a href="#入门案例-2" class="headerlink" title="入门案例"></a>入门案例</h4><p><strong>新建springcloud-zuul模块，并导入依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;    &lt;!--导入zuul依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;&#x2F;artifactId        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--Hystrix依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifac        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--dashboard依赖--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-hystrix-dashboar        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--Ribbon--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-ribbon&lt;&#x2F;artifact        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--Eureka--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifact        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--实体类+web--&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.haust&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;springcloud-api&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--热部署--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-devtools&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p><strong>application.yml</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 9527spring:  application:    name: springcloud-zuul #微服务名称eureka:  client:    service-url:      defaultZone: http:&#x2F;&#x2F;eureka7001.com:7001&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7002.com:7002&#x2F;eureka&#x2F;,http:&#x2F;&#x2F;eureka7003.com:7003&#x2F;eureka&#x2F;  instance: #实例的id    instance-id: zuul9527.com    prefer-ip-address: true # 显示ipinfo:  app.name: haust.springcloud #项目名称  company.name: haust #公司名称zuul:  routes:    mydept.serviceId: springcloud-provider-dept    mydept.path: &#x2F;mydept&#x2F;**    ignored-services: &quot;*&quot;  # 不能再使用某个(*：全部)路径访问了，ignored ： 忽略,隐藏全部的~    prefix: &#x2F;kuagn # 设置公共的前缀,实现隐藏原有路由</span><br></pre></td></tr></table></figure>

<p><img src="https://img-blog.csdnimg.cn/20200521132228379.png#pic_center" alt="[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-pc2gKhub-1590035798590)(C:\Users\dell\AppData\Roaming\Typora\typora-user-images\image-20200520211031365.png)]"></p>
<p><strong>主启动类</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableZuulProxy &#x2F;&#x2F;开启Zuulpublic class ZuulApplication_9527 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ZuulApplication_9527.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>详情参考springcloud中文社区zuul组件 :<a target="_blank" rel="noopener" href="https://www.springcloud.cc/spring-cloud-greenwich.html#_router_and_filter_zuul">https://www.springcloud.cc/spring-cloud-greenwich.html#_router_and_filter_zuul</a></p>
<h2 id="10-Spring-Cloud-Config-分布式配置"><a href="#10-Spring-Cloud-Config-分布式配置" class="headerlink" title="10. Spring Cloud Config 分布式配置"></a>10. Spring Cloud Config 分布式配置</h2><p><strong>Dalston.RELEASE</strong></p>
<p><strong>Spring Cloud Config为分布式系统中的外部配置提供服务器和客户端支持</strong>。使用Config Server，您可以在所有环境中管理应用程序的外部属性。客户端和服务器上的概念映射与Spring <code>Environment</code>和<code>PropertySource</code>抽象相同，因此它们与Spring应用程序非常契合，但可以与任何以任何语言运行的应用程序一起使用。随着应用程序通过从开发人员到测试和生产的部署流程，您可以管理这些环境之间的配置，并确定应用程序具有迁移时需要运行的一切。服务器存储后端的默认实现使用git，因此它轻松支持标签版本的配置环境，以及可以访问用于管理内容的各种工具。很容易添加替代实现，并使用Spring配置将其插入。</p>
<h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p><strong>分布式系统面临的—配置文件问题</strong></p>
<p>微服务意味着要将单体应用中的业务拆分成一个个子服务，每个服务的粒度相对较小，因此系统中会出现大量的服务，由于每个服务都需要必要的配置信息才能运行，所以一套集中式的，动态的配置管理设施是必不可少的。spring cloud提供了configServer来解决这个问题，我们每一个微服务自己带着一个application.yml，那上百个的配置文件修改起来，令人头疼！</p>
<p><strong>什么是SpringCloud config分布式配置中心？</strong></p>
<p><img src="https://img-blog.csdnimg.cn/202005211322530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p> spring cloud config 为微服务架构中的微服务提供集中化的外部支持，配置服务器为各个不同微服务应用的所有环节提供了一个<strong>中心化的外部配置</strong>。</p>
<p> spring cloud config 分为<strong>服务端</strong>和<strong>客户端</strong>两部分。</p>
<p> 服务端也称为 <strong>分布式配置中心</strong>，它是一个独立的微服务应用，用来连接配置服务器并为客户端提供获取配置信息，加密，解密信息等访问接口。</p>
<p> 客户端则是<strong>通过指定的配置中心来管理应用资源，以及与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息</strong>。配置服务器默认采用git来存储配置信息，这样就有助于对环境配置进行版本管理。并且可用通过git客户端工具来方便的管理和访问配置内容。</p>
<p><strong>spring cloud config 分布式配置中心能干嘛？</strong></p>
<ul>
<li>集中式管理配置文件</li>
<li>不同环境，不同配置，动态化的配置更新，分环境部署，比如 /dev /test /prod /beta /release</li>
<li>运行期间动态调整配置，不再需要在每个服务部署的机器上编写配置文件，服务会向配置中心统一拉取配置自己的信息</li>
<li>当配置发生变动时，服务不需要重启，即可感知到配置的变化，并应用新的配置</li>
<li>将配置信息以REST接口的形式暴露</li>
</ul>
<p><strong>spring cloud config 分布式配置中心与GitHub整合</strong></p>
<p> 由于spring cloud config 默认使用git来存储配置文件 (也有其他方式，比如自持SVN 和本地文件)，但是最推荐的还是git ，而且使用的是 http / https 访问的形式。</p>
<h4 id="入门案例-3"><a href="#入门案例-3" class="headerlink" title="入门案例"></a>入门案例</h4><h5 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a><strong>服务端</strong></h5><p>新建springcloud-config-server-3344模块导入pom.xml依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;    &lt;!--web--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;    &lt;&#x2F;dependency&gt;    &lt;!--config--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-config-server&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.1.1.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;    &lt;!--eureka--&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.4.6.RELEASE&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure>

<p>resource下创建application.yml配置文件，Spring Cloud Config服务器从git存储库（必须提供）为远程客户端提供配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server:  port: 3344spring:  application:    name: springcloud-config-server  # 连接码云远程仓库  cloud:    config:      server:        git:          #注意是https的而不是ssh          uri: https:&#x2F;&#x2F;gitee.com&#x2F;cao_shi_peng&#x2F;springcloud-config.git             # 通过 config-server可以连接到git，访问其中的资源以及配置~# 不加这个配置会报Cannot execute request on any known server 这个错：连接Eureka服务端地址不对# 或者直接注释掉eureka依赖 这里暂时用不到eurekaeureka:  client:    register-with-eureka: false    fetch-registry: false</span><br></pre></td></tr></table></figure>

<p>主启动类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@EnableConfigServer &#x2F;&#x2F;开启spring cloud config server服务@SpringBootApplicationpublic class Config_server_3344 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(Config_server_3344.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>将本地git仓库springcloud-config文件夹下新建的application.yml提交到码云仓库：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132326502.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>定位资源的默认策略是克隆一个git仓库（在<code>spring.cloud.config.server.git.uri</code>），并使用它来初始化一个迷你<code>SpringApplication</code>。小应用程序的<code>Environment</code>用于枚举属性源并通过JSON端点发布。</p>
<p>HTTP服务具有以下格式的资源：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#123;application&#125;&#x2F;&#123;profile&#125;[&#x2F;&#123;label&#125;]&#x2F;&#123;application&#125;-&#123;profile&#125;.yml&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;.yml&#x2F;&#123;application&#125;-&#123;profile&#125;.properties&#x2F;&#123;label&#125;&#x2F;&#123;application&#125;-&#123;profile&#125;.properties</span><br></pre></td></tr></table></figure>

<p>其中“应用程序”作为<code>SpringApplication</code>中的<code>spring.config.name</code>注入（即常规的Spring Boot应用程序中通常是“应用程序”），“配置文件”是活动配置文件（或逗号分隔列表的属性），“label”是可选的git标签（默认为“master”）。</p>
<p>测试访问<a target="_blank" rel="noopener" href="http://localhost:3344/application-dev.yml">http://localhost:3344/application-dev.yml</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521132350566.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>测试访问 <a target="_blank" rel="noopener" href="http://localhost:3344/application/test/master">http://localhost:3344/application/test/master</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521132406474.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>测试访问 <a target="_blank" rel="noopener" href="http://localhost:3344/master/application-dev.yml">http://localhost:3344/master/application-dev.yml</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521132423447.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>如果测试访问不存在的配置则不显示 如：<a target="_blank" rel="noopener" href="http://localhost:3344/master/application-aaa.yml">http://localhost:3344/master/application-aaa.yml</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521132439404.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<h5 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a><strong>客户端</strong></h5><p>将本地git仓库springcloud-config文件夹下新建的config-client.yml提交到码云仓库：</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132503261.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>新建一个springcloud-config-client-3355模块，并导入依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--config--&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-start&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.1.1.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-actuator&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;&lt;&#x2F;dependency&gt;pendencies&gt;</span><br></pre></td></tr></table></figure>

<p>resources下创建application.yml和bootstrap.yml配置文件</p>
<p>bootstrap.yml是系统级别的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 系统级别的配置spring:  cloud:    config:      name: config-client # 需要从git上读取的资源名称，不要后缀      profile: dev      label: master      uri: http:&#x2F;&#x2F;localhost:3344</span><br></pre></td></tr></table></figure>

<p>application.yml是用户级别的配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># 用户级别的配置spring:  application:    name: springcloud-config-client</span><br></pre></td></tr></table></figure>

<p>创建controller包下的ConfigClientController.java用于测试</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RestControllerpublic class ConfigClientController &#123;    @Value(&quot;$&#123;spring.application.name&#125;&quot;)    private String applicationName; &#x2F;&#x2F;获取微服务名称    @Value(&quot;$&#123;eureka.client.service-url.defaultZone&#125;&quot;)    private String eurekaServer; &#x2F;&#x2F;获取Eureka服务    @Value(&quot;$&#123;server.port&#125;&quot;)    private String port; &#x2F;&#x2F;获取服务端的端口号    @RequestMapping(&quot;&#x2F;config&quot;)    public String getConfig()&#123;        return &quot;applicationName:&quot;+applicationName +         &quot;eurekaServer:&quot;+eurekaServer +         &quot;port:&quot;+port;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>主启动类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplicationpublic class ConfigClient &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigClient.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>测试：</p>
<p>启动服务端Config_server_3344 再启动客户端ConfigClient</p>
<p>访问：<a target="_blank" rel="noopener" href="http://localhost:8201/config/">http://localhost:8201/config/</a></p>
<p><img src="https://img-blog.csdnimg.cn/20200521132534867.png#pic_center" alt="在这里插入图片描述"></p>
<p><strong>小案例</strong></p>
<p>本地新建config-dept.yml和config-eureka.yml并提交到码云仓库</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132550150.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20200521132601463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>
<p>这里配置文件内容不再列举直接到代码中看把。</p>
<p>新建springcloud-config-eureka-7001模块，并将原来的springcloud-eureka-7001模块下的内容拷贝的该模块。</p>
<p>1.清空该模块的application.yml配置，并新建bootstrap.yml连接远程配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring:  cloud:    config:      name: config-eureka # 仓库中的配置文件名称      label: master      profile: dev      uri: http:&#x2F;&#x2F;localhost:3344</span><br></pre></td></tr></table></figure>

<p>2.在pom.xml中添加spring cloud config依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--config--&gt;&lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework.cloud&#x2F;spring-cloud-starter-config --&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-config&lt;&#x2F;artifactId&gt;    &lt;version&gt;2.1.1.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure>

<p>3.主启动类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableEurekaServer &#x2F;&#x2F;EnableEurekaServer 服务端的启动类，可以接受别人注册进来~public class ConfigEurekaServer_7001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigEurekaServer_7001.class,args);    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>4.测试</p>
<p>第一步：启动 Config_Server_3344，并访问 <a target="_blank" rel="noopener" href="http://localhost:3344/master/config-eureka-dev.yml">http://localhost:3344/master/config-eureka-dev.yml</a> 测试</p>
<p><img src="https://img-blog.csdnimg.cn/2020052113262082.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>第二部：启动ConfigEurekaServer_7001，访问 <a target="_blank" rel="noopener" href="http://localhost:7001/">http://localhost:7001/</a> 测试</p>
<p><img src="https://img-blog.csdnimg.cn/20200521132633925.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzU5MTk4MA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>显示上图则成功</p>
<p>新建springcloud-config-dept-8001模块并拷贝springcloud-provider-dept-8001的内容</p>
<p>同理导入spring cloud config依赖、清空application.yml 、新建bootstrap.yml配置文件并配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring:  cloud:    config:      name: config-dept      label: master      profile: dev      uri: http:&#x2F;&#x2F;localhost:3344</span><br></pre></td></tr></table></figure>

<p>主启动类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication@EnableEurekaClient &#x2F;&#x2F;在服务启动后自动注册到Eureka中！@EnableDiscoveryClient &#x2F;&#x2F;服务发现~@EnableCircuitBreaker &#x2F;&#x2F;public class ConfigDeptProvider_8001 &#123;    public static void main(String[] args) &#123;        SpringApplication.run(ConfigDeptProvider_8001.class,args);    &#125;    &#x2F;&#x2F;增加一个 Servlet    @Bean    public ServletRegistrationBean hystrixMetricsStreamServlet()&#123;        ServletRegistrationBean registrationBean &#x3D; new ServletRegistrationBean(new HystrixMetricsStreamServlet());        registrationBean.addUrlMappings(&quot;&#x2F;actuator&#x2F;hystrix.stream&quot;);        return registrationBean;    &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>测试 (略)</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2021/04/21/Spring%20Boot%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2021/04/21/Spring%20Boot%E8%AF%BE%E5%A0%82%E7%AC%94%E8%AE%B0/" class="post-title-link" itemprop="url">Untitled</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-04-21 16:24:35" itemprop="dateCreated datePublished" datetime="2021-04-21T16:24:35+08:00">2021-04-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2020-07-11 19:34:37" itemprop="dateModified" datetime="2020-07-11T19:34:37+08:00">2020-07-11</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="1-Spring-Boot概述"><a href="#1-Spring-Boot概述" class="headerlink" title="1. Spring Boot概述"></a>1. Spring Boot概述</h2><p><strong>目标</strong>：了解Spring Boot是什么，有什么作用</p>
<p><strong>小结</strong>：</p>
<p>Spring Boot是一个便捷搭建 基于spring工程的脚手架；作用是帮助开发人员快速搭建大型的spring 项目。简化工程的配置，依赖管理；实现开发人员把时间都集中在业务开发上。</p>
<h2 id="2-Spring-Boot入门"><a href="#2-Spring-Boot入门" class="headerlink" title="2. Spring Boot入门"></a>2. Spring Boot入门</h2><p><strong>目标</strong>：能够使用Spring Boot搭建项目</p>
<p><strong>分析</strong>：</p>
<p>需求：可以在浏览器中访问<a target="_blank" rel="noopener" href="http://localhost:8080/hello%E8%BE%93%E5%87%BA%E4%B8%80%E4%B8%B2%E5%AD%97%E7%AC%A6">http://localhost:8080/hello输出一串字符</a></p>
<p>实现步骤：</p>
<ol>
<li>创建工程；</li>
<li>添加依赖（启动器依赖，spring-boot-starter-web）；</li>
<li>创建启动类；</li>
<li>创建处理器Controller；</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<p>Spring Boot工程可以通过添加启动器依赖和创建启动引导类实现快速创建web工程。</p>
<blockquote>
<p>spring-boot-starter-web默认的应用服务器端口是8080</p>
</blockquote>
<h2 id="3-Java代码方式配置"><a href="#3-Java代码方式配置" class="headerlink" title="3. Java代码方式配置"></a>3. Java代码方式配置</h2><p><strong>目标</strong>：可以使用@Value获取配置文件配置项并结合@Bean注册组件到Spring</p>
<p><strong>分析</strong>：</p>
<p>需求：使用Java代码配置数据库连接池，并可以在处理器中注入并使用</p>
<p>步骤：</p>
<ol>
<li>添加依赖；</li>
<li>创建数据库；</li>
<li>创建数据库连接参数的配置文件jdbc.properties；</li>
<li>创建配置类；</li>
<li>改造处理器类注入数据源并使用</li>
</ol>
<p><strong>小结</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource(&quot;classpath:jdbc.properties&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span></span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span></span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.username&#125;&quot;)</span></span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span></span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="4-Spring-Boot属性注入方式"><a href="#4-Spring-Boot属性注入方式" class="headerlink" title="4. Spring Boot属性注入方式"></a>4. Spring Boot属性注入方式</h2><p><strong>目标</strong>：能够使用@ConfigurationProperties实现Spring Boot配置文件配置项读取和应用</p>
<p><strong>分析</strong>：</p>
<p>需求：将配置文件中的配置项读取到一个对象中；</p>
<p>实现：可以使用Spring Boot提供的注解@ConfigurationProperties，该注解可以将Spring Boot的配置文件（默认必须为application.properties或application.yml）中的配置项读取到一个对象中。</p>
<p>实现步骤：</p>
<ol>
<li>创建配置项类JdbcProperties类，在该类名上面添加@ConfigurationProperties；</li>
<li>将jdbc.properties修改名称为application.properties；</li>
<li>将JdbcProperties对象注入到JdbcConfig；</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li>使用@ConfigurationProperties编写配置项类将配置文件中的配置项设置到对象中</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUrl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUrl</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDriverClassName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> driverClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDriverClassName</span><span class="params">(String driverClassName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.driverClassName = driverClassName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.username = username;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.password = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<ul>
<li>使用@ConfigurationProperties在方法上面使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties(prefix = &quot;jdbc&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="3-5-多个yml文件配置"><a href="#3-5-多个yml文件配置" class="headerlink" title="3.5. 多个yml文件配置"></a>3.5. 多个yml文件配置</h2><p><strong>目标</strong>：可以将多个yml文件在application.yml文件中配置激活</p>
<p><strong>分析</strong>：</p>
<p>yaml与properties配置文件除了展示形式不相同以外，其它功能和作用都是一样的；在项目中原路的读取方式不需要改变。</p>
<p>1）yml配置文件的特征：</p>
<ol>
<li>树状层级结构展示配置项；</li>
<li>配置项之间如果有关系的话需要分行空两格；</li>
<li>配置项如果有值的话，那么需要在 <code>:</code>之后空一格再写配置项值；</li>
</ol>
<p>将application.properties配置文件修改为application.yml的话：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">jdbc:</span></span><br><span class="line">  <span class="attr">driverClassName:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/heima</span></span><br><span class="line">  <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">  <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br><span class="line"><span class="attr">key:</span></span><br><span class="line">  <span class="attr">abc:</span> <span class="string">cba</span></span><br><span class="line">  <span class="attr">def:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">g</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">h</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">j</span></span><br></pre></td></tr></table></figure>



<p>2）多个yml配置文件；在spring boot中是被允许的。这些配置文件的名称必须为application-***.yml，并且这些配置文件必须要在application.yml配置文件中激活之后才可以使用。</p>
<p>3）如果properties和yml配置文件同时存在在spring boot项目中；那么这两类配置文件都有效。在两个配置文件中如果存在同名的配置项的话会以properties文件的为主。</p>
<p><strong>小结</strong>：</p>
<p>在多个配置文件时，需要将这些文件在application.yml文件中进行激活：</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#激活配置文件;需要指定其它的配置文件名称</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">abc,def</span></span><br></pre></td></tr></table></figure>



<h2 id="6-自动配置原理"><a href="#6-自动配置原理" class="headerlink" title="6. 自动配置原理"></a>6. 自动配置原理</h2><p><strong>目标</strong>：了解Spring Boot项目的配置加载流程</p>
<p><strong>小结</strong>：</p>
<ul>
<li>在 <code>META-INF\spring.fatories</code>文件中定义了很多自动配置类；可以根据在pom.xml文件中添加的 启动器依赖自动配置组件</li>
<li>通过如下流程可以去修改application配置文件，改变自动配置的组件默认参数</li>
</ul>
<p><img src="C:\Users\Timor\AppData\Roaming\Typora\typora-user-images\image-20200708183728364.png" alt="image-20200708183728364"></p>
<h2 id="7-lombok应用"><a href="#7-lombok应用" class="headerlink" title="7. lombok应用"></a>7. lombok应用</h2><p><strong>目标</strong>：使用lombok的注解实现pojo类的简化</p>
<p><strong>分析</strong>：</p>
<p>使用Spring Boot整合SSM工程；需要使用到数据库数据。</p>
<ul>
<li><p>将数据库表数据导入到数据库中（springboot_test）；</p>
</li>
<li><p>编写数据库表对应的实体类；一般情况下需要编写get/set/toString等这些方法会耗时并且会让实体类看起来比较臃肿。可以使用lombok插件对实体类进行简化。</p>
<p>lombok是一个插件工具类包；提供了一些注解@Data、@Getter等这些注解去简化实体类中的构造方法、get/set等方法的编写。</p>
<ol>
<li>在IDEA中安装lombok插件；</li>
<li>添加lombok对应的依赖到项目pom.xml文件；</li>
<li>改造实体类使用lombok注解</li>
</ol>
</li>
</ul>
<p><strong>小结</strong>：</p>
<p>在Bean上使用：<br>@Data ：自动提供getter和setter、hashCode、equals、toString等方法<br>@Getter：自动提供getter方法<br>@Setter：自动提供setter方法<br>@Slf4j：自动在bean中提供log变量，其实用的是slf4j的日志功能。</p>
<h2 id="8-Spring-Boot整合-SpringMVC端口和静态资源"><a href="#8-Spring-Boot整合-SpringMVC端口和静态资源" class="headerlink" title="8. Spring Boot整合-SpringMVC端口和静态资源"></a>8. Spring Boot整合-SpringMVC端口和静态资源</h2><p><strong>目标</strong>：可以修改tomcat的端口和访问项目中的静态资源</p>
<p><strong>分析</strong>：</p>
<ul>
<li><p>修改tomcat端口</p>
<p>查询**Properties，设置配置项（前缀+类变量名）到application配置文件中</p>
</li>
<li><p>访问项目中的静态资源</p>
<p>静态资源放置的位置；放置静态资源并访问这些资源</p>
</li>
</ul>
<p><strong>小结</strong>：</p>
<ul>
<li>修改项目tomcat端口：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#tomcat端口</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>在spring boot项目中静态资源可以放置在如下目录：</p>
<p><img src="assets/1560096384799.png" alt="1560096384799"> </p>
</li>
</ul>
<h2 id="9-Spring-Boot整合-SpringMVC拦截器"><a href="#9-Spring-Boot整合-SpringMVC拦截器" class="headerlink" title="9.Spring Boot整合-SpringMVC拦截器"></a>9.Spring Boot整合-SpringMVC拦截器</h2><p><strong>目标</strong>：可以在Spring Boot项目中配置自定义SpringMVC拦截器</p>
<p><strong>分析</strong>：</p>
<ol>
<li>编写拦截器（实现HandlerInterceptor）；</li>
<li>编写配置类实现 WebMvcConfigurer，在该类中添加各种组件；</li>
<li>测试</li>
</ol>
<p><strong>小结</strong>：</p>
<p>可以在spring boot项目中通过配置类添加各种组件；如果要添加拦截器的话：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.itheima.interceptor.MyInterceptor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.InterceptorRegistry;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注册拦截器</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MyInterceptor <span class="title">myInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MyInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加拦截器到spring mvc拦截器链</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.addInterceptor(myInterceptor()).addPathPatterns(<span class="string">&quot;/*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="10-Spring-Boot整合-事务和连接池"><a href="#10-Spring-Boot整合-事务和连接池" class="headerlink" title="10. Spring Boot整合-事务和连接池"></a>10. Spring Boot整合-事务和连接池</h2><p><strong>目标</strong>：配置Spring Boot自带默认的hikari数据库连接池和使用@Transactional注解进行事务配置</p>
<p><strong>分析</strong>：</p>
<ul>
<li><p>事务配置</p>
<ol>
<li>添加事务相关的启动器依赖，mysql相关依赖；</li>
<li>编写业务类UserService使用事务注解@Transactional</li>
</ol>
</li>
<li><p>数据库连接池hikari配置</p>
<p>只需要在application配置文件中指定数据库相关参数</p>
</li>
</ul>
<p><strong>小结</strong>：</p>
<ul>
<li>事务配置；只需要添加jdbc启动器依赖</li>
<li>数据库连接池使用默认的hikari，在配置文件中配置如下：</li>
</ul>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">datasource:</span></span><br><span class="line">    <span class="attr">driver-class-name:</span> <span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/springboot_test</span></span><br><span class="line">    <span class="attr">username:</span> <span class="string">root</span></span><br><span class="line">    <span class="attr">password:</span> <span class="string">root</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="11-Spring-Boot整合-Mybatis"><a href="#11-Spring-Boot整合-Mybatis" class="headerlink" title="11. Spring Boot整合-Mybatis"></a>11. Spring Boot整合-Mybatis</h2><p><strong>目标</strong>：配置Mybatis在Spring Boot工程中的整合包，设置mybatis的实体类别名，输出执行sql语句配置项</p>
<p><strong>分析</strong>：</p>
<ol>
<li>添加启动器依赖；</li>
<li>配置Mybatis：实体类别名包，日志，映射文件等；</li>
<li>配置MapperScan</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li><p>添加mybatis官方对于spring boot的一个启动器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  </span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>配置mybatis</p>
<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mybatis:</span></span><br><span class="line">  <span class="comment"># 实体类别名包路径</span></span><br><span class="line">  <span class="attr">type-aliases-package:</span> <span class="string">com.itheima.pojo</span></span><br><span class="line">  <span class="comment"># 映射文件路径</span></span><br><span class="line">  <span class="comment"># mapper-locations: classpath:mappers/*.xml</span></span><br><span class="line">  <span class="attr">configuration:</span></span><br><span class="line">    <span class="attr">log-impl:</span> <span class="string">org.apache.ibatis.logging.stdout.StdOutImpl</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>设置启动器类中的mapper扫描</p>
<p><img src="assets/1560178298122.png" alt="1560178298122"> </p>
</li>
</ul>
<h2 id="12-Spring-Boot整合-通用Mapper"><a href="#12-Spring-Boot整合-通用Mapper" class="headerlink" title="12. Spring Boot整合-通用Mapper"></a>12. Spring Boot整合-通用Mapper</h2><p><strong>目标</strong>：配置通用Mapper组件到Spring Boot项目中并使用Mapper<T>接口</p>
<p><strong>分析</strong>：</p>
<p>通用Mapper：可以实现自动拼接sql语句；所有的mapper都不需要编写任何方法也就是不用编写sql语句。可以提高开发效率。</p>
<ol>
<li>添加启动器依赖；</li>
<li>改造UserMapper继承Mapper<User>；</li>
<li>修改启动引导类Application中的Mapper扫描注解；</li>
<li>修改User实体类 添加jpa注解；</li>
<li>改造UserService实现业务功能；</li>
</ol>
<p><strong>小结</strong>：</p>
<blockquote>
<p>在启动引导类上面的mapper扫描注解 一定要修改为 通用mapper的扫描注解</p>
</blockquote>
<h2 id="13-Spring-Boot整合测试"><a href="#13-Spring-Boot整合测试" class="headerlink" title="13. Spring Boot整合测试"></a>13. Spring Boot整合测试</h2><p><strong>目标</strong>：可以访问处理器对应路径将数据库中的数据根据id查询</p>
<p><strong>分析</strong>：</p>
<ol>
<li>改造HelloController，注入UserService利用其方法实现查询；</li>
<li>启动项目进行测试 <a target="_blank" rel="noopener" href="http://localhost/user/%E7%94%A8%E6%88%B7id">http://localhost/user/用户id</a> –&gt; <a target="_blank" rel="noopener" href="http://localhost/user/8">http://localhost/user/8</a></li>
</ol>
<p><strong>小结</strong>：</p>
<p>修改了HelloController：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据用户id查询用户</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> id 用户id</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 用户</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/user/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(<span class="meta">@PathVariable</span> Long id)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="14-Spring-Boot整合-Junit"><a href="#14-Spring-Boot整合-Junit" class="headerlink" title="14. Spring Boot整合-Junit"></a>14. Spring Boot整合-Junit</h2><p><strong>目标</strong>：在Spring Boot项目中使用Junit进行单元测试UserService的方法</p>
<p><strong>分析</strong>：</p>
<ol>
<li>添加启动器依赖spring-boot-starter-test；</li>
<li>编写测试类</li>
</ol>
<p><strong>小结</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">queryById</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = userService.queryById(<span class="number">8L</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;user = &quot;</span> + user);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setUserName(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">        user.setName(<span class="string">&quot;test2&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">13</span>);</span><br><span class="line">        user.setPassword(<span class="string">&quot;123456&quot;</span>);</span><br><span class="line">        user.setSex(<span class="number">1</span>);</span><br><span class="line">        user.setCreated(<span class="keyword">new</span> Date());</span><br><span class="line">        userService.saveUser(user);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在Spring Boot项目中如果编写测试类则必须要在类上面添加@SpringBootTest</p>
</blockquote>
<h2 id="15-Spring-Boot整合-redis"><a href="#15-Spring-Boot整合-redis" class="headerlink" title="15. Spring Boot整合-redis"></a>15. Spring Boot整合-redis</h2><p><strong>目标</strong>：在Spring Boot项目中使用Junit测试RedisTemplate的使用</p>
<p><strong>分析</strong>：</p>
<ol>
<li>添加启动器依赖；spring-boot-starter-data-redis</li>
<li>配置application.yml中修改redis的连接参数；（redis需要启动）</li>
<li>编写测试类应用RedisTemplate操作redis中的5种数据类型（string/hash/list/set/sorted set）</li>
</ol>
<p><strong>小结</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith(SpringRunner.class)</span></span><br><span class="line"><span class="meta">@SpringBootTest</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RedisTemplate redisTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//string 字符串</span></span><br><span class="line">        <span class="comment">//redisTemplate.opsForValue().set(&quot;str&quot;, &quot;heima&quot;);</span></span><br><span class="line">        redisTemplate.boundValueOps(<span class="string">&quot;str&quot;</span>).set(<span class="string">&quot;heima&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;str = &quot;</span> + redisTemplate.opsForValue().get(<span class="string">&quot;str&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//hash 散列</span></span><br><span class="line">        redisTemplate.boundHashOps(<span class="string">&quot;h_key&quot;</span>).put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;heima&quot;</span>);</span><br><span class="line">        redisTemplate.boundHashOps(<span class="string">&quot;h_key&quot;</span>).put(<span class="string">&quot;age&quot;</span>, <span class="number">13</span>);</span><br><span class="line">        <span class="comment">//获取所有域</span></span><br><span class="line">        Set set = redisTemplate.boundHashOps(<span class="string">&quot;h_key&quot;</span>).keys();</span><br><span class="line">        System.out.println(<span class="string">&quot; hash散列的所有域：&quot;</span> + set);</span><br><span class="line">        <span class="comment">//获取所有值</span></span><br><span class="line">        List list = redisTemplate.boundHashOps(<span class="string">&quot;h_key&quot;</span>).values();</span><br><span class="line">        System.out.println(<span class="string">&quot; hash散列的所有域的值：&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//list 列表</span></span><br><span class="line">        redisTemplate.boundListOps(<span class="string">&quot;l_key&quot;</span>).leftPush(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">        redisTemplate.boundListOps(<span class="string">&quot;l_key&quot;</span>).leftPush(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">        redisTemplate.boundListOps(<span class="string">&quot;l_key&quot;</span>).leftPush(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">        <span class="comment">//获取全部元素</span></span><br><span class="line">        list = redisTemplate.boundListOps(<span class="string">&quot;l_key&quot;</span>).range(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; list列表中的所有元素：&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// set 集合</span></span><br><span class="line">        redisTemplate.boundSetOps(<span class="string">&quot;s_key&quot;</span>).add(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>);</span><br><span class="line">        set = redisTemplate.boundSetOps(<span class="string">&quot;s_key&quot;</span>).members();</span><br><span class="line">        System.out.println(<span class="string">&quot; set集合中的所有元素：&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// sorted set 有序集合</span></span><br><span class="line">        redisTemplate.boundZSetOps(<span class="string">&quot;z_key&quot;</span>).add(<span class="string">&quot;a&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        redisTemplate.boundZSetOps(<span class="string">&quot;z_key&quot;</span>).add(<span class="string">&quot;b&quot;</span>, <span class="number">20</span>);</span><br><span class="line">        redisTemplate.boundZSetOps(<span class="string">&quot;z_key&quot;</span>).add(<span class="string">&quot;c&quot;</span>, <span class="number">10</span>);</span><br><span class="line">        set = redisTemplate.boundZSetOps(<span class="string">&quot;z_key&quot;</span>).range(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot; zset有序集合中的所有元素：&quot;</span> + set);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h2 id="16-Spring-Boot项目部署"><a href="#16-Spring-Boot项目部署" class="headerlink" title="16. Spring Boot项目部署"></a>16. Spring Boot项目部署</h2><p><strong>目标</strong>：将Spring Boot项目使用maven指令打成jar包并运行测试</p>
<p><strong>分析</strong>：</p>
<ol>
<li>需要添加打包组件将项目中的资源、配置、依赖包打到一个jar包中；可以使用maven的<code>package</code>；</li>
<li>部署：java -jar 包名</li>
</ol>
<p><strong>小结</strong>：</p>
<ul>
<li><p>添加打包组件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 打jar包时如果不配置该插件，打出来的jar包没有清单文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>部署运行</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar 包名</span><br></pre></td></tr></table></figure>

</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">John Doe</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">13</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
